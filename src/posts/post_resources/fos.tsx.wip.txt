
import React, { ReactNode, useEffect, useMemo, useState } from 'react';
import FosScopeBuilder from './fosScopeBuilder';

type Primitive = string | number | boolean;
type ScalarBase = 'String' | 'Number' | 'Boolean';
type Modality = 'cartesian' | 'linear';
type TypeFlavor = 'struct' | 'sigma' | 'pi' | 'observation';

interface ScalarType {
  kind: 'scalar';
  base: ScalarBase;
  multiline?: boolean;
}

interface LiteralType {
  kind: 'literal';
  value: Primitive;
}

type FosTypeDescriptor = ScalarType | LiteralType;
type TypeResolver = FosTypeDescriptor | ((ctx: Record<string, unknown>) => FosTypeDescriptor);

export interface FieldDescriptor {
  name: string;
  label?: string;
  type: TypeResolver;
  optional?: boolean;
  input?: 'text' | 'textarea';
}

export interface StructTypeDescriptor {
  name: string;
  label?: string;
  predicate: string;
  fields: FieldDescriptor[];
  identityField?: string;
  kind: TypeFlavor;
  observes?: string;
  dimension: number;
  sourceField?: string;
  targetField?: string;
  modality: Modality;
}

export interface HoleDescriptor {
  name: string;
  typeName: string;
  description?: string;
  factPredicate?: string;
  pi?: {
    parameter: string;
    viaField?: string;
    modality: Modality;
  };
}

export interface ProgramDefinition {
  name: string;
  types: Record<string, StructTypeDescriptor>;
  holes: HoleDescriptor[];
  predicateToType: Record<string, string>;
}

type FosEvent =
  | { kind: 'fact-asserted'; fact: Fact; timestamp: number }
  | { kind: 'hole-filled'; holeName: string; value: Record<string, unknown>; timestamp: number }
  | { kind: 'linear-consumed'; typeName: string; identity: string; timestamp: number };

interface EventStorage {
  load(): FosEvent[];
  append(event: FosEvent): void;
}

interface Fact {
  predicate: string;
  args: Record<string, unknown>;
  timestamp: number;
}

interface QueryPattern {
  predicate: string;
  args?: Record<string, PatternValue>;
}

interface QueryResult {
  fact: Fact;
  bindings: Record<string, unknown>;
}

interface VarPattern {
  kind: 'var';
  name: string;
}

type PatternValue = Primitive | VarPattern | Record<string, PatternValue>;

interface LinearResourceState {
  identity: string;
  consumed: boolean;
  fact?: Fact;
}

interface ConsumptionRequest {
  typeName: string;
  identity: string;
}

interface CallEndpointOptions {
  consumeLinear?: ConsumptionRequest[];
}

const isObject = (value: unknown): value is Record<string, unknown> => typeof value === 'object' && value !== null;

const slugify = (value: string): string =>
  value
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '')
    .trim()
    .replace(/\s+/g, '-');

const clone = <T,>(value: T): T => JSON.parse(JSON.stringify(value));

type FosAstComponent<P> = React.FC<P> & { fosKind: 'program' | 'type' | 'field' | 'hole' };

interface ProgramProps {
  name: string;
  children: React.ReactNode;
}

interface TypeProps {
  name: string;
  label?: string;
  predicate?: string;
  identity?: string;
  observes?: string;
  sourceField?: string;
  targetField?: string;
  modality?: Modality;
  form?: Exclude<TypeFlavor, 'observation'>;
  children: React.ReactNode;
}

interface FieldProps {
  name: string;
  label?: string;
  type: TypeResolver;
  optional?: boolean;
  input?: 'text' | 'textarea';
}

interface HoleProps {
  name: string;
  type: string;
  description?: string;
  fact?: string;
  pi?: {
    parameter: string;
    viaField?: string;
    modality?: Modality;
  };
}

function createAstComponent<P>(kind: 'program' | 'type' | 'field' | 'hole') {
  const Wrap = (props: { children?: ReactNode }) => <>{props.children}</>;
  const Component = Wrap as FosAstComponent<P>;
  Component.fosKind = kind;
  return Component;
}

export const ProgramNode = createAstComponent<ProgramProps>('program');
export const TypeNode = createAstComponent<TypeProps>('type');
export const FieldNode = createAstComponent<FieldProps>('field');
export const HoleNode = createAstComponent<HoleProps>('hole');

const resolveType = (resolver: TypeResolver, ctx: Record<string, unknown>): FosTypeDescriptor =>
  typeof resolver === 'function' ? resolver(ctx) : resolver;

// eslint-disable-next-line react-refresh/only-export-components
export const literal = (value: Primitive): LiteralType => ({ kind: 'literal', value });
// eslint-disable-next-line react-refresh/only-export-components
export const scalar = (base: ScalarBase, multiline = false): ScalarType => ({ kind: 'scalar', base, multiline });

const finalizeTypeGraph = (types: Record<string, StructTypeDescriptor>) => {
  const memo = new Map<string, number>();
  const visiting = new Set<string>();

  const visit = (name: string): number => {
    if (memo.has(name)) return memo.get(name)!;
    const descriptor = types[name];
    if (!descriptor) {
      throw new Error(`Unknown type referenced: ${name}`);
    }

    if (!descriptor.observes) {
      descriptor.dimension = 0;
      memo.set(name, 0);
      return 0;
    }

    if (!types[descriptor.observes]) {
      throw new Error(`Type "${descriptor.name}" observes missing type "${descriptor.observes}".`);
    }

    if (visiting.has(name)) {
      throw new Error(`Circular observation detected at "${name}".`);
    }

    visiting.add(name);
    const baseDimension = visit(descriptor.observes);
    visiting.delete(name);

    const dimension = baseDimension + 1;
    descriptor.dimension = dimension;
    memo.set(name, dimension);
    return dimension;
  };

  Object.keys(types).forEach(visit);
};

const interpretProgram = (ast: React.ReactElement): ProgramDefinition => {
  if (!React.isValidElement(ast) || (ast.type as FosAstComponent<ProgramProps>).fosKind !== 'program') {
    throw new Error('Fos program must start with <ProgramNode>.');
  }

  const programProps = ast.props as ProgramProps;
  const types: Record<string, StructTypeDescriptor> = {};
  const holes: HoleDescriptor[] = [];

  React.Children.forEach(programProps.children, child => {
    if (!React.isValidElement(child)) return;
    const meta = child.type as FosAstComponent<unknown>;

    if (meta.fosKind === 'type') {
      const typeProps = child.props as TypeProps;
      const fields: FieldDescriptor[] = [];

      React.Children.forEach(typeProps.children, fieldChild => {
        if (!React.isValidElement(fieldChild)) return;
        const fieldMeta = fieldChild.type as FosAstComponent<FieldProps>;
        if (fieldMeta.fosKind !== 'field') return;

        fields.push(fieldChild.props as FieldDescriptor);
      });

      const flavor: TypeFlavor = typeProps.observes ? 'observation' : typeProps.form ?? 'struct';

      const descriptor: StructTypeDescriptor = {
        name: typeProps.name,
        label: typeProps.label ?? typeProps.name,
        predicate: typeProps.predicate ?? typeProps.name.toLowerCase(),
        fields,
        identityField: typeProps.identity,
        kind: flavor,
        observes: typeProps.observes,
        dimension: 0,
        sourceField: typeProps.observes ? typeProps.sourceField ?? 'from' : undefined,
        targetField: typeProps.observes ? typeProps.targetField ?? 'to' : undefined,
        modality: typeProps.modality ?? 'cartesian',
      };

      types[typeProps.name] = descriptor;
    }

    if (meta.fosKind === 'hole') {
      const holeProps = child.props as HoleProps;
      holes.push({
        name: holeProps.name,
        typeName: holeProps.type,
        description: holeProps.description,
        factPredicate: holeProps.fact,
        pi: holeProps.pi
          ? {
              parameter: holeProps.pi.parameter,
              viaField: holeProps.pi.viaField,
              modality: holeProps.pi.modality ?? 'cartesian',
            }
          : undefined,
      });
    }
  });

  finalizeTypeGraph(types);

  const predicateToType: Record<string, string> = {};
  Object.values(types).forEach(type => {
    predicateToType[type.predicate] = type.name;
  });

  return {
    name: programProps.name,
    types,
    holes,
    predicateToType,
  };
};

class EventStream {
  private listeners = new Set<(event: FosEvent) => void>();

  emit(event: FosEvent) {
    this.listeners.forEach(listener => listener(event));
  }

  subscribe(listener: (event: FosEvent) => void) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }
}

export class MemoryEventStorage implements EventStorage {
  private events: FosEvent[];

  constructor(initialEvents: FosEvent[] = []) {
    this.events = [...initialEvents];
  }

  load() {
    return [...this.events];
  }

  append(event: FosEvent) {
    this.events.push(event);
  }
}

export class LocalStorageEventStorage implements EventStorage {
  private cache: FosEvent[] | null = null;

  constructor(private key: string, private fallback: EventStorage = new MemoryEventStorage()) {}

  private get store() {
    if (typeof window === 'undefined' || !window.localStorage) return null;
    return window.localStorage;
  }

  load() {
    if (this.cache) return [...this.cache];
    const store = this.store;
    if (!store) return this.fallback.load();
    const raw = store.getItem(this.key);
    if (!raw) {
      this.cache = [];
      return [];
    }
    try {
      this.cache = JSON.parse(raw);
    } catch (error) {
      console.warn('Failed to parse fos event log, resetting.', error);
      this.cache = [];
      store.removeItem(this.key);
    }
    return [...this.cache];
  }

  append(event: FosEvent) {
    const store = this.store;
    if (!store) {
      this.fallback.append(event);
      return;
    }
    const events = this.load();
    events.push(event);
    this.cache = events;
    store.setItem(this.key, JSON.stringify(events));
  }
}

interface NodeFs {
  readFileSync(path: string, encoding: BufferEncoding): string;
  writeFileSync(path: string, data: string): void;
  existsSync(path: string): boolean;
}

export class FileEventStorage implements EventStorage {
  constructor(private path: string, private fs: NodeFs | null) {}

  private ensureFs() {
    if (!this.fs) throw new Error('File system adapter missing. Pass an fs implementation from the CLI environment.');
    return this.fs;
  }

  load() {
    const fs = this.fs;
    if (!fs) return [];
    if (!fs.existsSync(this.path)) return [];
    const raw = fs.readFileSync(this.path, 'utf-8');
    return raw ? (JSON.parse(raw) as FosEvent[]) : [];
  }

  append(event: FosEvent) {
    const fs = this.ensureFs();
    const events = this.load();
    events.push(event);
    fs.writeFileSync(this.path, JSON.stringify(events, null, 2));
  }
}

const tryNormalizePrimitive = (value: unknown): Primitive => {
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') return value;
  if (value === null || value === undefined) return '';
  return String(value);
};

export const FosVar = (name: string): VarPattern => ({ kind: 'var', name });

const isVarPattern = (value: PatternValue): value is VarPattern =>
  isObject(value) && 'kind' in value && (value as VarPattern).kind === 'var';

const unify = (
  pattern: PatternValue,
  candidate: unknown,
  bindings: Record<string, unknown>
): Record<string, unknown> | null => {
  if (isVarPattern(pattern)) {
    const existing = bindings[pattern.name];
    if (existing === undefined) {
      bindings[pattern.name] = candidate;
      return bindings;
    }
    return JSON.stringify(existing) === JSON.stringify(candidate) ? bindings : null;
  }

  if (isObject(pattern)) {
    if (!isObject(candidate)) return null;
    for (const key of Object.keys(pattern)) {
      const nextBindings = unify(pattern[key]!, candidate[key], bindings);
      if (!nextBindings) return null;
      bindings = nextBindings;
    }
    return bindings;
  }

  return Object.is(pattern, candidate) ? bindings : null;
};

class UnionFind {
  private parent = new Map<string, string>();
  private rank = new Map<string, number>();

  private ensure(value: string) {
    if (!this.parent.has(value)) {
      this.parent.set(value, value);
      this.rank.set(value, 0);
    }
  }

  find(value: string): string {
    this.ensure(value);
    const parent = this.parent.get(value)!;
    if (parent !== value) {
      const root = this.find(parent);
      this.parent.set(value, root);
      return root;
    }
    return parent;
  }

  union(a: string, b: string) {
    const rootA = this.find(a);
    const rootB = this.find(b);
    if (rootA === rootB) return;
    const rankA = this.rank.get(rootA)!;
    const rankB = this.rank.get(rootB)!;
    if (rankA < rankB) {
      this.parent.set(rootA, rootB);
    } else if (rankA > rankB) {
      this.parent.set(rootB, rootA);
    } else {
      this.parent.set(rootB, rootA);
      this.rank.set(rootA, rankA + 1);
    }
  }

  touch(value: string) {
    this.ensure(value);
  }

  groups(): string[][] {
    const clusters = new Map<string, Set<string>>();
    for (const value of this.parent.keys()) {
      const root = this.find(value);
      if (!clusters.has(root)) {
        clusters.set(root, new Set());
      }
      clusters.get(root)!.add(value);
    }
    return Array.from(clusters.values()).map(group => Array.from(group));
  }
}

type HoleHandler = (value: Record<string, unknown>, runtime: FosRuntime) => void;

export class FosRuntime {
  private facts: Fact[] = [];
  private eventStream = new EventStream();
  private holeHandlers = new Map<string, HoleHandler>();
  private storage: EventStorage;
  private homotopies = new Map<string, UnionFind>();
  private predicateToType: Record<string, string>;
  private linearResources = new Map<string, Map<string, LinearResourceState>>();

  constructor(private definition: ProgramDefinition, storage?: EventStorage) {
    this.storage = storage ?? new MemoryEventStorage();
    this.predicateToType = definition.predicateToType;
    const existing = this.storage.load();
    existing.forEach(event => this.applyEvent(event));
  }

  subscribe(listener: (event: FosEvent) => void) {
    return this.eventStream.subscribe(listener);
  }

  describeType(name: string) {
    const type = this.definition.types[name];
    if (!type) throw new Error(`Unknown type ${name}`);
    return type;
  }

  getProgramName() {
    return this.definition.name;
  }

  getTypeDimension(name: string) {
    return this.describeType(name).dimension;
  }

  getHoles() {
    return [...this.definition.holes];
  }

  registerHoleHandler(holeName: string, handler: HoleHandler) {
    this.holeHandlers.set(holeName, handler);
  }

  callEndpoint(holeName: string, value: Record<string, unknown>, options?: CallEndpointOptions) {
    const descriptor = this.definition.holes.find(h => h.name === holeName);
    if (!descriptor) throw new Error(`Unknown hole ${holeName}`);
    const normalized = this.normalizeStructValue(descriptor.typeName, value);
    this.validateStructValue(descriptor.typeName, normalized);

    const consumptionRecords: ConsumptionRequest[] = [...(options?.consumeLinear ?? [])];
    if (descriptor.pi?.modality === 'linear' && descriptor.pi.viaField) {
      const identityValue = normalized[descriptor.pi.viaField];
      if (identityValue !== undefined && identityValue !== null) {
        consumptionRecords.push({
          typeName: descriptor.pi.parameter,
          identity: String(identityValue),
        });
      }
    }
    this.verifyLinearRequests(consumptionRecords);

    const event: FosEvent = { kind: 'hole-filled', holeName, value: normalized, timestamp: Date.now() };
    this.persistEvent(event);
    const factPredicate = descriptor.factPredicate ?? this.describeType(descriptor.typeName).predicate;
    this.assertFact(factPredicate, normalized);
    this.consumeLinearRequests(consumptionRecords);
    const handler = this.holeHandlers.get(holeName);
    if (handler) handler(normalized, this);
  }

  assertFact(predicate: string, args: Record<string, unknown>) {
    const fact: Fact = { predicate, args: clone(args), timestamp: Date.now() };
    const event: FosEvent = { kind: 'fact-asserted', fact, timestamp: fact.timestamp };
    this.persistEvent(event);
  }

  private persistEvent(event: FosEvent) {
    this.applyEvent(event);
    this.storage.append(event);
    this.eventStream.emit(event);
  }

  private applyEvent(event: FosEvent) {
    if (event.kind === 'fact-asserted') {
      this.applyFact(event.fact);
      return;
    }

    if (event.kind === 'hole-filled') {
      return;
    }

    if (event.kind === 'linear-consumed') {
      this.markLinearConsumed(event.typeName, event.identity);
      return;
    }
  }

  private findTypeByPredicate(predicate: string) {
    const typeName = this.predicateToType[predicate];
    return typeName ? this.definition.types[typeName] : undefined;
  }

  private applyFact(fact: Fact) {
    this.facts.push(fact);
    const descriptor = this.findTypeByPredicate(fact.predicate);
    if (!descriptor) return;
    if (descriptor.kind === 'struct' || descriptor.kind === 'sigma' || descriptor.kind === 'pi') {
      this.registerIdentityValue(descriptor, fact.args, fact);
    } else if (descriptor.kind === 'observation') {
      this.applyObservationFact(descriptor, fact);
    }
  }

  private getUnionFind(typeName: string) {
    if (!this.homotopies.has(typeName)) {
      this.homotopies.set(typeName, new UnionFind());
    }
    return this.homotopies.get(typeName)!;
  }

  private registerIdentityValue(descriptor: StructTypeDescriptor, value: Record<string, unknown>, fact: Fact) {
    const identityField = descriptor.identityField;
    if (!identityField) return;
    const identity = value[identityField];
    if (identity === undefined || identity === null) return;
    const identityStr = String(identity);
    this.getUnionFind(descriptor.name).touch(identityStr);
    if (descriptor.modality === 'linear') {
      const resources = this.ensureLinearTable(descriptor.name);
      const existing = resources.get(identityStr);
      if (!existing) {
        resources.set(identityStr, { identity: identityStr, consumed: false, fact });
      } else if (!existing.fact) {
        existing.fact = fact;
      }
    }
  }

  private applyObservationFact(descriptor: StructTypeDescriptor, fact: Fact) {
    if (!descriptor.observes) return;
    const observedDescriptor = this.describeType(descriptor.observes);
    const identityField = observedDescriptor.identityField;
    if (!identityField) return;
    const sourceField = descriptor.sourceField ?? 'from';
    const targetField = descriptor.targetField ?? 'to';
    const source = fact.args[sourceField];
    const target = fact.args[targetField];
    if (source === undefined || target === undefined) return;
    this.getUnionFind(observedDescriptor.name).union(String(source), String(target));
  }

  getEquivalenceClasses(typeName: string) {
    const uf = this.homotopies.get(typeName);
    if (!uf) return [];
    return uf.groups();
  }

  getLinearResources(typeName: string) {
    const table = this.linearResources.get(typeName);
    if (!table) return [];
    return Array.from(table.values());
  }

  private verifyLinearRequests(records: ConsumptionRequest[]) {
    records.forEach(record => {
      const table = this.linearResources.get(record.typeName);
      if (!table || !table.has(record.identity)) {
        throw new Error(`Linear resource ${record.identity} of type ${record.typeName} is not available.`);
      }
      const state = table.get(record.identity)!;
      if (state.consumed) {
        throw new Error(`Linear resource ${record.identity} of type ${record.typeName} has already been consumed.`);
      }
    });
  }

  private consumeLinearRequests(records: ConsumptionRequest[]) {
    records.forEach(record => {
      const event: FosEvent = {
        kind: 'linear-consumed',
        typeName: record.typeName,
        identity: record.identity,
        timestamp: Date.now(),
      };
      this.persistEvent(event);
    });
  }

  private markLinearConsumed(typeName: string, identity: string) {
    const table = this.linearResources.get(typeName);
    if (!table || !table.has(identity)) return;
    table.get(identity)!.consumed = true;
  }

  queryFacts(pattern: QueryPattern): QueryResult[] {
    const relevant = this.facts.filter(fact => fact.predicate === pattern.predicate);
    return relevant
      .map(fact => {
        const initialBindings: Record<string, unknown> = {};
        const argsPattern = pattern.args;
        if (!argsPattern) {
          return {
            fact,
            bindings: {},
          };
        }
        const unified = unify(argsPattern as PatternValue, fact.args, initialBindings);
        if (!unified) return null;
        return {
          fact,
          bindings: unified,
        };
      })
      .filter((result): result is QueryResult => result !== null);
  }

  createBlankValue(typeName: string) {
    const descriptor = this.describeType(typeName);
    const accumulator: Record<string, unknown> = {};
    descriptor.fields.forEach(field => {
      const context = { ...accumulator };
      const resolved = resolveType(field.type, context);
      if (resolved.kind === 'literal') {
        accumulator[field.name] = resolved.value;
      } else if (resolved.kind === 'scalar') {
        accumulator[field.name] = '';
      }
    });
    return accumulator;
  }

  normalizeStructValue(typeName: string, draft: Record<string, unknown>) {
    const descriptor = this.describeType(typeName);
    const normalized: Record<string, unknown> = {};
    descriptor.fields.forEach(field => {
      const context = { ...draft, ...normalized };
      const resolved = resolveType(field.type, context);
      if (resolved.kind === 'literal') {
        normalized[field.name] = resolved.value;
      } else if (resolved.kind === 'scalar') {
        normalized[field.name] = tryNormalizePrimitive(draft[field.name]);
      }
    });
    return normalized;
  }

  validateStructValue(typeName: string, value: Record<string, unknown>) {
    const descriptor = this.describeType(typeName);
    descriptor.fields.forEach(field => {
      if (!field.optional && !(field.name in value)) {
        throw new Error(`Missing value for ${field.name}`);
      }
      const resolved = resolveType(field.type, value);
      const current = value[field.name];
      if (resolved.kind === 'literal' && current !== resolved.value) {
        throw new Error(`Field ${field.name} must equal ${resolved.value}`);
      }
      if (resolved.kind === 'scalar') {
        if (resolved.base === 'String' && typeof current !== 'string') {
          throw new Error(`Field ${field.name} must be a string`);
        }
      }
    });
  }
}

export interface FosCliTransport {
  write(message: string): void;
  onLine(listener: (line: string) => void): void;
}

// eslint-disable-next-line react-refresh/only-export-components
export const attachCliServer = (runtime: FosRuntime, transport: FosCliTransport) => {
  const helpText = [
    'Commands:',
    '- add <description> : fills the Todo hole using the provided description',
    '- ticket <id> [scope] : mints a linear ticket identified by <id>',
    '- list               : prints all todo facts',
    '- query <term>       : prints todos whose description matches the provided term',
    '- help               : prints this message',
  ];

  transport.write(`Fos runtime ${runtime.getProgramName()} ready.\n`);
  transport.write(helpText.join('\n') + '\n');

  transport.onLine(line => {
    const [command, ...rest] = line.trim().split(' ');
    if (!command) return;
    if (command === 'help') {
      transport.write(helpText.join('\n') + '\n');
      return;
    }
    if (command === 'add') {
      const description = rest.join(' ');
      if (!description) {
        transport.write('Description required.\n');
        return;
      }
      runtime.callEndpoint('createTodo', { description });
      transport.write('Added todo via hole endpoint.\n');
      return;
    }
    if (command === 'ticket') {
      if (rest.length === 0) {
        transport.write('Usage: ticket <id> [scope]\n');
        return;
      }
      const [ticketId, ...scopeParts] = rest;
      const scope = scopeParts.join(' ') || 'cli';
      runtime.callEndpoint('issueTicket', {
        ticketId,
        scope,
        issued: new Date().toISOString(),
      });
      transport.write(`Issued ticket ${ticketId} scoped to "${scope}".\n`);
      return;
    }
    if (command === 'list') {
      const results = runtime.queryFacts({ predicate: 'todo' });
      transport.write(JSON.stringify(results.map(result => result.fact.args), null, 2) + '\n');
      return;
    }
    if (command === 'query') {
      const needle = rest.join(' ');
      const results = runtime.queryFacts({
        predicate: 'todo',
        args: {
          description: needle || FosVar('description'),
        },
      });
      transport.write(JSON.stringify(results.map(result => result.fact.args), null, 2) + '\n');
      return;
    }
    transport.write('Unknown command. Type "help" for options.\n');
  });
};

const renderFieldInput = (
  field: FieldDescriptor,
  resolvedType: FosTypeDescriptor,
  value: Record<string, unknown>,
  onFieldChange: (name: string, next: unknown) => void
) => {
  const current = value[field.name];

  if (resolvedType.kind === 'literal') {
    return (
      <div key={field.name} className="flex flex-col gap-1 text-sm">
        <span className="text-foreground/70">{field.label ?? field.name}</span>
        <div className="rounded-full border border-white/10 bg-white/10 px-3 py-1 text-xs uppercase tracking-widest text-foreground/80">
          {String(resolvedType.value)}
        </div>
      </div>
    );
  }

  if (resolvedType.kind === 'scalar') {
    const commonProps = {
      id: field.name,
      name: field.name,
      value: typeof current === 'string' ? current : '',
      onChange: (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) =>
        onFieldChange(field.name, event.target.value),
      placeholder: field.label ?? field.name,
      className:
        'w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20',
    };

    return (
      <div key={field.name} className="flex flex-col gap-1 text-sm">
        <label htmlFor={field.name} className="text-foreground/70">
          {field.label ?? field.name}
        </label>
        {resolvedType.multiline || field.input === 'textarea' ? (
          <textarea {...commonProps} rows={3} />
        ) : (
          <input {...commonProps} />
        )}
      </div>
    );
  }

  return null;
};

const useFosRuntime = (definition: ProgramDefinition) => {
  const storage = useMemo(() => new LocalStorageEventStorage(`fos.events.${definition.name}`), [definition.name]);
  const runtime = useMemo(() => new FosRuntime(definition, storage), [definition, storage]);
  const [, setTick] = useState(0);

  useEffect(() => runtime.subscribe(() => setTick(tick => tick + 1)), [runtime]);

  return runtime;
};

const ProgramShell: React.FC<{ title?: string; children: React.ReactNode; description?: string }> = ({
  title,
  children,
  description,
}) => (
  <section className="rounded-2xl border border-white/10 bg-slate-900/60 p-6 shadow-2xl shadow-black/40 backdrop-blur-sm">
    {(title || description) && (
      <header className="mb-4 space-y-2">
        {title && <p className="text-xs uppercase tracking-[0.25em] text-foreground/60">{title}</p>}
        {description && <p className="text-sm text-foreground/70">{description}</p>}
      </header>
    )}
    <div className="space-y-6 text-sm">{children}</div>
  </section>
);

export const FosWrapperComponent = () => {
  const programAst = useMemo(
    () => (
      <ProgramNode name="TodoRuntime">
        <TypeNode name="TodoTicket" label="Todo Ticket" predicate="todoTicket" identity="ticketId" modality="linear" form="sigma">
          <FieldNode name="ticketId" label="Ticket ID" type={scalar('String')} />
          <FieldNode name="scope" label="Scope" type={scalar('String')} />
          <FieldNode
            name="issued"
            label="Issued At"
            type={() => literal(new Date().toISOString())}
          />
        </TypeNode>
        <TypeNode name="Todo" label="Todo Item" predicate="todo" identity="slug">
          <FieldNode name="description" label="Task description" type={scalar('String', true)} />
          <FieldNode
            name="slug"
            label="Slug"
            type={(ctx: Record<string, unknown>) => literal(slugify((ctx.description as string) ?? ''))}
          />
          <FieldNode name="ticketId" label="Ticket" type={scalar('String')} />
        </TypeNode>
        <TypeNode
          name="TodoPath"
          label="Todo Homotopy"
          predicate="todoPath"
          observes="Todo"
          sourceField="fromSlug"
          targetField="toSlug"
        >
          <FieldNode name="fromSlug" label="From Todo" type={scalar('String')} />
          <FieldNode name="toSlug" label="To Todo" type={scalar('String')} />
          <FieldNode name="witness" label="Witness" type={scalar('String', true)} input="textarea" />
        </TypeNode>
        <HoleNode
          name="createTodo"
          description="Captures new todo tasks when the dependent hole is filled."
          type="Todo"
          fact="todo"
          pi={{ parameter: 'TodoTicket', viaField: 'ticketId', modality: 'linear' }}
        />
        <HoleNode
          name="issueTicket"
          description="Mints a linear Todo ticket (Sigma type) that must be spent once."
          type="TodoTicket"
          fact="todoTicket"
        />
        <HoleNode
          name="linkTodos"
          description="Registers a higher observational path between two todos."
          type="TodoPath"
          fact="todoPath"
        />
      </ProgramNode>
    ),
    []
  );

  const programDefinition = useMemo(() => interpretProgram(programAst), [programAst]);
  const runtime = useFosRuntime(programDefinition);
  const [formState, setFormState] = useState<Record<string, unknown>>(() => runtime.createBlankValue('Todo'));
  const [pathForm, setPathForm] = useState<Record<string, unknown>>(() => runtime.createBlankValue('TodoPath'));
  const [ticketForm, setTicketForm] = useState<Record<string, unknown>>(() => runtime.createBlankValue('TodoTicket'));
  const [queryFilter, setQueryFilter] = useState('');

  useEffect(() => {
    setFormState(runtime.createBlankValue('Todo'));
    setPathForm(runtime.createBlankValue('TodoPath'));
    setTicketForm(runtime.createBlankValue('TodoTicket'));
  }, [runtime]);

  const todoType = runtime.describeType('Todo');
  const todoPathType = runtime.describeType('TodoPath');
  const createTodoHole = runtime.getHoles().find(hole => hole.name === 'createTodo');
  const piDescriptor = createTodoHole?.pi;
  const todoDimension = runtime.getTypeDimension('Todo');
  const todoPathDimension = runtime.getTypeDimension('TodoPath');
  const sourceField = todoPathType.sourceField ?? 'fromSlug';
  const targetField = todoPathType.targetField ?? 'toSlug';

  const onFieldChange = (name: string, next: unknown) => {
    const draft = { ...formState, [name]: next };
    setFormState(runtime.normalizeStructValue('Todo', draft));
  };

  const onSubmit = (event: React.FormEvent) => {
    event.preventDefault();
    if (!formState.ticketId || typeof formState.ticketId !== 'string' || formState.ticketId.length === 0) {
      window.alert('Mint and select a Todo ticket (linear resource) before creating a Todo.');
      return;
    }
    runtime.callEndpoint('createTodo', formState);
    setFormState(runtime.createBlankValue('Todo'));
  };

  const onTicketFieldChange = (name: string, next: unknown) => {
    const draft = { ...ticketForm, [name]: next };
    setTicketForm(runtime.normalizeStructValue('TodoTicket', draft));
  };

  const generateTicketId = () => {
    const randomId = `ticket-${Math.random().toString(36).slice(2, 7)}-${Date.now().toString(36)}`;
    setTicketForm(form => ({ ...form, ticketId: randomId }));
  };

  const onTicketSubmit = (event: React.FormEvent) => {
    event.preventDefault();
    if (!ticketForm.ticketId || typeof ticketForm.ticketId !== 'string' || ticketForm.ticketId.length === 0) {
      window.alert('Provide a ticket ID (use the generator for convenience).');
      return;
    }
    runtime.callEndpoint('issueTicket', ticketForm);
    setTicketForm(runtime.createBlankValue('TodoTicket'));
  };

  const onPathFieldChange = (name: string, next: unknown) => {
    const draft = { ...pathForm, [name]: next };
    setPathForm(runtime.normalizeStructValue('TodoPath', draft));
  };

  const onPathSubmit = (event: React.FormEvent) => {
    event.preventDefault();
    const sourceField = todoPathType.sourceField ?? 'fromSlug';
    const targetField = todoPathType.targetField ?? 'toSlug';
    const source = pathForm[sourceField];
    const target = pathForm[targetField];
    if (!source || !target) return;
    if (String(source) === String(target)) return;
    runtime.callEndpoint('linkTodos', pathForm);
    setPathForm(runtime.createBlankValue('TodoPath'));
  };

  const ticketType = runtime.describeType('TodoTicket');
  const ticketResources = runtime.getLinearResources('TodoTicket');
  const availableTicketStates = ticketResources.filter(resource => !resource.consumed);
  const availableTicketKey = availableTicketStates.map(resource => resource.identity).join('|');

  useEffect(() => {
    setFormState(prev => {
      const current = typeof prev.ticketId === 'string' ? prev.ticketId : '';
      const firstAvailable = availableTicketStates[0]?.identity ?? '';
      if (!firstAvailable) {
        if (!current) return prev;
        return { ...prev, ticketId: '' };
      }
      if (current && availableTicketStates.some(state => state.identity === current)) {
        return prev;
      }
      return { ...prev, ticketId: firstAvailable };
    });
  }, [availableTicketKey, availableTicketStates]);

  const todos = runtime.queryFacts({
    predicate: 'todo',
    args: {
      description: queryFilter ? queryFilter : FosVar('description'),
      slug: FosVar('slug'),
    },
  });

  const allTodos = runtime.queryFacts({ predicate: 'todo' });
  const slugToTodo = new Map<string, string>();
  allTodos.forEach(result => {
    const slugValue = result.fact.args.slug;
    if (typeof slugValue === 'string') {
      const description = typeof result.fact.args.description === 'string' ? result.fact.args.description : slugValue;
      slugToTodo.set(slugValue, description);
    }
  });
  const slugOptions = Array.from(slugToTodo.keys());
  const availableTicketOptions = availableTicketStates.map(state => ({
    identity: state.identity,
    scope: typeof state.fact?.args.scope === 'string' ? (state.fact?.args.scope as string) : 'Unscoped',
    issued: typeof state.fact?.args.issued === 'string' ? (state.fact?.args.issued as string) : undefined,
  }));
  const consumedTicketStates = ticketResources.filter(resource => resource.consumed);
  const ticketStats = {
    total: ticketResources.length,
    available: availableTicketStates.length,
    consumed: consumedTicketStates.length,
  };
  const todoPaths = runtime.queryFacts({ predicate: 'todoPath' });
  const equivalenceClasses = runtime.getEquivalenceClasses('Todo');

  return (
    <div className="flex flex-col gap-10">
      <ProgramShell>
        <FosScopeBuilder />
      </ProgramShell>

      <details className="rounded-3xl border border-white/10 bg-black/30 p-4 shadow-inner shadow-black/20">
        <summary className="cursor-pointer text-xs uppercase tracking-[0.4em] text-foreground/50">
          Advanced Fos Runtime (optional)
        </summary>
        <div className="mt-6 flex flex-col gap-8">
          <ProgramShell
            title="Σ Tickets (Linear Modality)"
            description="Mint Σ-pairs that package a ticket identifier with its scope. Because they are linear, each ticket can be consumed only once."
          >
            <form onSubmit={onTicketSubmit} className="space-y-4">
              <div className="grid gap-4 md:grid-cols-2">
                {ticketType.fields.map(field => {
                  const resolved = resolveType(field.type, ticketForm);
                  const fieldNode = renderFieldInput(field, resolved, ticketForm, onTicketFieldChange);
                  if (field.name !== 'ticketId') return fieldNode;
                  return (
                    <div key={field.name} className="flex flex-col gap-2">
                      {fieldNode}
                      <button
                        type="button"
                        className="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-xs uppercase tracking-widest text-foreground/70 transition hover:border-white/30"
                        onClick={generateTicketId}
                      >
                        Generate Ticket ID
                      </button>
                    </div>
                  );
                })}
              </div>
              <div className="grid gap-3 md:grid-cols-2">
                <div className="rounded-xl border border-white/10 bg-white/5 p-3 text-center text-xs uppercase tracking-widest text-foreground/60">
                  Available <span className="block text-2xl font-semibold text-white">{ticketStats.available}</span>
                </div>
                <div className="rounded-xl border border-white/10 bg-white/5 p-3 text-center text-xs uppercase tracking-widest text-foreground/60">
                  Consumed <span className="block text-2xl font-semibold text-white">{ticketStats.consumed}</span>
                </div>
              </div>
              <button
                type="submit"
                className="w-full rounded-xl bg-amber-400/80 py-3 text-center text-sm font-semibold uppercase tracking-wide text-amber-900 shadow-lg shadow-amber-900/30 transition hover:bg-amber-300"
              >
                Mint Linear Ticket
              </button>
            </form>

            <ul className="mt-4 space-y-2 text-sm">
              {ticketResources.map(resource => (
                <li
                  key={resource.identity}
                  className="rounded-xl border border-white/5 bg-white/5 px-4 py-3 flex flex-col md:flex-row md:items-center md:justify-between gap-2"
                >
                  <div>
                    <p className="font-semibold text-white">
                      {resource.identity}{' '}
                      <span className="ml-2 rounded-full border border-white/10 px-2 py-0.5 text-xs uppercase tracking-wide text-foreground/60">
                        Σ scope: {String(resource.fact?.args.scope ?? 'Unscoped')}
                      </span>
                    </p>
                    <p className="text-xs text-foreground/50">
                      Issued {resource.fact?.args.issued ? new Date(resource.fact.args.issued as string).toLocaleString() : '—'}
                    </p>
                  </div>
                  <span
                    className={`rounded-full px-3 py-1 text-xs uppercase tracking-widest ${
                      resource.consumed
                        ? 'bg-rose-500/20 text-rose-200 border border-rose-500/50'
                        : 'bg-emerald-500/20 text-emerald-200 border border-emerald-500/40'
                    }`}
                  >
                    {resource.consumed ? 'Consumed' : 'Available'}
                  </span>
                </li>
              ))}
              {ticketResources.length === 0 && (
                <li className="rounded-xl border border-dashed border-white/20 px-4 py-3 text-foreground/60">
                  Mint a ticket to seed the linear resource pool.
                </li>
              )}
            </ul>
          </ProgramShell>

          <ProgramShell
            title="Π Endpoint: Ticket ⊸ Todo"
            description={
              piDescriptor
                ? `This hole is typed as Π(${piDescriptor.parameter} → ${createTodoHole?.typeName}) with ${piDescriptor.modality} modality on the argument. Spend one Σ ticket above to inhabit the Todo.`
                : 'Fill the dependently typed Todo goal and watch the runtime advertise new paths to every connected peer.'
            }
          >
            <form onSubmit={onSubmit} className="space-y-4">
              <div className="grid gap-4 md:grid-cols-2">
                {todoType.fields.map(field => {
                  if (field.name === 'ticketId') {
                    return (
                      <div key={field.name} className="flex flex-col gap-1 text-sm">
                        <label className="text-foreground/70" htmlFor="todo-ticket-select">
                          Ticket (linear)
                        </label>
                        <select
                          id="todo-ticket-select"
                          value={typeof formState.ticketId === 'string' ? formState.ticketId : ''}
                          onChange={event => setFormState(prev => ({ ...prev, ticketId: event.target.value }))}
                          className="w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                          disabled={availableTicketOptions.length === 0}
                        >
                          {availableTicketOptions.map(option => (
                            <option key={option.identity} value={option.identity}>
                              {option.identity} · {option.scope}
                            </option>
                          ))}
                        </select>
                        {availableTicketOptions.length === 0 && (
                          <p className="text-xs text-rose-300/80">No tickets available. Mint one above.</p>
                        )}
                      </div>
                    );
                  }
                  const resolved = resolveType(field.type, formState);
                  return renderFieldInput(field, resolved, formState, onFieldChange);
                })}
              </div>
              <button
                type="submit"
                disabled={availableTicketOptions.length === 0}
                className="w-full rounded-xl bg-emerald-500/80 py-3 text-center text-sm font-semibold uppercase tracking-wide text-emerald-950 shadow-lg shadow-emerald-900/40 transition hover:bg-emerald-400 disabled:cursor-not-allowed disabled:opacity-40"
              >
                Fill Hole / Add Todo
              </button>
            </form>
          </ProgramShell>

          <ProgramShell
            title="Homotopy / Observational Paths"
            description={`Following the higher observational types strategy popularized by Narya, the TodoPath type observes Todo, lifting us from dimension ${todoDimension} to ${todoPathDimension}. Each witness glues two endpoints so any CLI, WebRTC peer, or browser session can reason about the resulting homotopy classes.`}
          >
            <form onSubmit={onPathSubmit} className="space-y-4">
              <div className="grid gap-4 md:grid-cols-2">
                {todoPathType.fields.map(field => {
                  const resolved = resolveType(field.type, pathForm);
                  if (field.name === sourceField || field.name === targetField) {
                    return (
                      <div key={field.name} className="flex flex-col gap-1 text-sm">
                        <label className="text-foreground/70" htmlFor={`path-${field.name}`}>
                          {field.label ?? field.name}
                        </label>
                        <select
                          id={`path-${field.name}`}
                          name={field.name}
                          value={(pathForm[field.name] as string) ?? ''}
                          onChange={event => onPathFieldChange(field.name, event.target.value)}
                          className="w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                        >
                          <option value="">Select a todo</option>
                          {slugOptions.map(slug => (
                            <option key={slug} value={slug}>
                              {(slugToTodo.get(slug) ?? slug) + ` (${slug})`}
                            </option>
                          ))}
                        </select>
                      </div>
                    );
                  }
                  return renderFieldInput(field, resolved, pathForm, onPathFieldChange);
                })}
              </div>
              <button
                type="submit"
                className="w-full rounded-xl bg-indigo-500/80 py-3 text-center text-sm font-semibold uppercase tracking-wide text-indigo-950 shadow-lg shadow-indigo-900/40 transition hover:bg-indigo-400"
              >
                Link Todos / Record Path
              </button>
            </form>

            <div className="space-y-4">
              <div>
                <h4 className="text-sm font-semibold uppercase tracking-widest text-foreground/60">Recorded paths</h4>
                <ul className="mt-2 space-y-2 text-sm">
                  {todoPaths.map(result => (
                    <li
                      key={result.fact.timestamp}
                      className="flex items-center justify-between rounded-xl border border-white/5 bg-white/5 px-4 py-2"
                    >
                      <span className="font-semibold text-white">
                        {String(result.fact.args[sourceField] ?? '??')} → {String(result.fact.args[targetField] ?? '??')}
                      </span>
                      {result.fact.args.witness && (
                        <span className="rounded-full bg-white/10 px-3 py-1 text-xs uppercase tracking-wide text-foreground/70">
                          {String(result.fact.args.witness)}
                        </span>
                      )}
                    </li>
                  ))}
                  {todoPaths.length === 0 && (
                    <li className="rounded-xl border border-dashed border-white/20 px-4 py-3 text-foreground/60">
                      No observational paths yet.
                    </li>
                  )}
                </ul>
              </div>

              <div>
                <h4 className="text-sm font-semibold uppercase tracking-widest text-foreground/60">π₀ Classes</h4>
                {equivalenceClasses.length === 0 && (
                  <p className="mt-2 text-sm text-foreground/60">Link two todos to create the first equivalence class.</p>
                )}
                <div className="mt-4 grid gap-4 md:grid-cols-2">
                  {equivalenceClasses.map((group, index) => (
                    <div
                      key={`${group.join('-')}-${index}`}
                      className="rounded-2xl border border-white/10 bg-gradient-to-br from-slate-900/50 to-slate-900/30 p-4 text-sm"
                    >
                      <p className="mb-2 text-xs uppercase tracking-widest text-foreground/50">Class {index + 1}</p>
                      <ul className="space-y-1">
                        {group.map(slug => (
                          <li key={slug} className="flex items-center justify-between">
                            <span>{slugToTodo.get(slug) ?? slug}</span>
                            <code className="rounded bg-black/40 px-2 py-0.5 text-xs text-foreground/70">{slug}</code>
                          </li>
                        ))}
                      </ul>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </ProgramShell>

          <ProgramShell
            title="Datalog-style Queries"
            description="Queries are just patterns. Leave the filter empty to bind the variable and inspect every Todo fact."
          >
            <div className="space-y-3">
              <input
                value={queryFilter}
                placeholder="Exact match filter"
                onChange={event => setQueryFilter(event.target.value)}
                className="w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
              />
              <ul className="space-y-2">
                {todos.map(result => (
                  <li
                    key={result.fact.timestamp}
                    className="flex flex-col rounded-xl border border-white/5 bg-white/5 px-4 py-3 text-sm text-white"
                  >
                    <strong className="text-base">{result.fact.args.description as string}</strong>
                    <span className="text-xs uppercase tracking-widest text-foreground/50">{result.fact.args.slug as string}</span>
                  </li>
                ))}
                {todos.length === 0 && (
                  <li className="rounded-xl border border-dashed border-white/20 px-4 py-3 text-foreground/60">No todos yet.</li>
                )}
              </ul>
            </div>
          </ProgramShell>

          <ProgramShell
            title="Event-driven Frontend & Backend"
            description="Storage stays abstract. The browser persists to localStorage, while a CLI/Node host can pass in a file-backed adapter."
          >
            <pre className="rounded-2xl bg-black/60 p-4 text-xs text-emerald-200">
{`const fs = require('fs');
const storage = new FileEventStorage('todos.json', fs);
const runtime = new FosRuntime(definition, storage);

runtime.callEndpoint('issueTicket', { ticketId: 'seed-1', scope: 'cli', issued: new Date().toISOString() });
runtime.callEndpoint('createTodo', { description: 'First task', slug: 'first-task', ticketId: 'seed-1' });
attachCliServer(runtime, transport);`}
            </pre>
          </ProgramShell>

        </div>
      </details>
    </div>
  );
};
