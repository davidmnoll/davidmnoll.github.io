import React, { ReactNode, useCallback, useEffect, useMemo, useState } from 'react';
import type { ContentId, DirectoryEntry, DirectoryNode, MerkleNode, MerkleStore } from '@/components/ui/merkleNavigator';
import { MerkleNavigator } from '@/components/ui/merkleNavigator';

type ResourceKind = 'none' | 'budget' | 'time' | 'asset' | 'custom' | 'fact';

interface CalendarSlot {
  id: string;
  start: string;
  end: string;
  label?: string;
  sourceVariableId?: string;
}

interface ResourceMetadata {
  kind: ResourceKind;
  label: string;
  quantity: number;
  unit: string;
  consumable: boolean;
  sourceVariableId?: string;
  resourceType?: string;
  origin?: 'manual' | 'task' | 'imported';
  lockedToScopeId?: ContentId;
  releasedToParent?: boolean;
  timeSlots?: CalendarSlot[];
  factType?: string;
  proofPath?: string;
  proofSourceTaskId?: string;
}

interface ScopeVariable {
  id: string;
  name: string;
  type: string;
  scopeId: ContentId;
  resource?: ResourceMetadata;
}

interface ScopeTaskResource {
  id: string;
  resource: ResourceMetadata;
  delivered?: boolean;
}

interface ScopeTask {
  id: string;
  title: string;
  description?: string;
  requiredResourceIds: string[];
  requiredFacts: string[];
  status: 'pending' | 'completed';
  producedResources: ScopeTaskResource[];
}

interface ScopeMetadata {
  nodeKind: 'scope';
  label: string;
  variables: ScopeVariable[];
  tasks: ScopeTask[];
  completed?: boolean;
}

type ExpressionBinding =
  | { kind: 'empty' }
  | { kind: 'hole' }
  | { kind: 'variable'; variableId: string }
  | { kind: 'expression'; nodeId: ContentId };

interface ExpressionField {
  id: string;
  name: string;
  binding: ExpressionBinding;
}

interface ExpressionMetadata {
  nodeKind: 'expression';
  label: string;
  typeName: string;
  fields: ExpressionField[];
}

interface ScopedVariableInfo extends ScopeVariable {
  scopeLabel: string;
}

const VARIABLE_DRAG_TYPE = 'application/x-fos-variable';

const createNodeId = (): ContentId =>
  `cid:${Math.random().toString(36).slice(2)}${Date.now().toString(36)}${Math.random().toString(36).slice(2)}` as ContentId;

const createScopeNode = (label: string): DirectoryNode => ({
  kind: 'directory',
  id: createNodeId(),
  entries: [],
  metadata: {
    nodeKind: 'scope',
    label,
    variables: [],
    tasks: [],
  } satisfies ScopeMetadata,
});

const createExpressionNode = (label: string, typeName: string): DirectoryNode => ({
  kind: 'directory',
  id: createNodeId(),
  entries: [],
  metadata: {
    nodeKind: 'expression',
    label,
    typeName,
    fields: [],
  } satisfies ExpressionMetadata,
});

const isDirectory = (node: MerkleNode | undefined): node is DirectoryNode => node?.kind === 'directory';

const isScopeMetadata = (metadata: DirectoryNode['metadata']): metadata is ScopeMetadata =>
  Boolean(metadata && (metadata as ScopeMetadata).nodeKind === 'scope');

const isExpressionMetadata = (metadata: DirectoryNode['metadata']): metadata is ExpressionMetadata =>
  Boolean(metadata && (metadata as ExpressionMetadata).nodeKind === 'expression');

const formatResourceSummary = (resource: ResourceMetadata | undefined) => {
  if (!resource || resource.kind === 'none') return null;
  if (resource.kind === 'budget') {
    return `$${resource.quantity.toFixed(2)} ${resource.label}`;
  }
  if (resource.kind === 'time') {
    const hours = resource.timeSlots ? sumSlotHours(resource.timeSlots) : resource.quantity;
    return `${hours}h ${resource.label}`;
  }
  if (resource.kind === 'fact') {
    return `${resource.factType ?? 'Fact'} (${resource.label})`;
  }
  return `${resource.quantity} ${resource.unit} ${resource.label}`;
};

const cloneScopeMetadata = (metadata: ScopeMetadata): ScopeMetadata => ({
  nodeKind: 'scope',
  label: metadata.label,
  variables: metadata.variables.map(variable => ({
    ...variable,
    resource: variable.resource ? { ...variable.resource } : undefined,
  })),
  tasks: metadata.tasks.map(task => ({
    ...task,
    producedResources: task.producedResources.map(resource => ({
      id: resource.id,
      resource: { ...resource.resource },
      delivered: resource.delivered,
    })),
  })),
  completed: metadata.completed,
});

const cloneExpressionMetadata = (metadata: ExpressionMetadata): ExpressionMetadata => ({
  nodeKind: 'expression',
  label: metadata.label,
  typeName: metadata.typeName,
  fields: metadata.fields.map(field => ({
    id: field.id,
    name: field.name,
    binding:
      field.binding.kind === 'expression'
        ? { kind: 'expression', nodeId: field.binding.nodeId }
        : field.binding.kind === 'variable'
          ? { kind: 'variable', variableId: field.binding.variableId }
          : field.binding.kind === 'hole'
            ? { kind: 'hole' }
            : { kind: 'empty' },
  })),
});

const gatherExpressionEntries = (fields: ExpressionField[]): DirectoryEntry[] =>
  fields
    .filter(field => field.binding.kind === 'expression')
    .map(field => ({
      name: field.name,
      ref: { kind: 'node', targetId: field.binding.nodeId },
    }));

const sanitizeEntryName = (existing: DirectoryEntry[], baseName: string): string => {
  if (!existing.some(entry => entry.name === baseName)) {
    return baseName;
  }

  let counter = 1;
  let candidate = `${baseName}-${counter}`;
  while (existing.some(entry => entry.name === candidate)) {
    counter += 1;
    candidate = `${baseName}-${counter}`;
  }
  return candidate;
};

const HOURS_PER_SLOT = 1;

const generateTimeSlots = (days: number, startHour = 9, endHour = 17): CalendarSlot[] => {
  const slots: CalendarSlot[] = [];
  const base = new Date();
  base.setMinutes(0, 0, 0);
  for (let dayIndex = 0; dayIndex < days; dayIndex += 1) {
    for (let hour = startHour; hour < endHour; hour += HOURS_PER_SLOT) {
      const start = new Date(base);
      start.setDate(base.getDate() + dayIndex);
      start.setHours(hour);
      const end = new Date(start);
      end.setHours(start.getHours() + HOURS_PER_SLOT);
      slots.push({
        id: `slot-${createNodeId()}`,
        start: start.toISOString(),
        end: end.toISOString(),
        label: start.toLocaleString(undefined, { weekday: 'short', hour: 'numeric' }),
      });
    }
  }
  return slots;
};

const sumSlotHours = (slots: CalendarSlot[]) => slots.length * HOURS_PER_SLOT;

const formatSlotLabel = (slot: CalendarSlot) => {
  const start = new Date(slot.start);
  const end = new Date(slot.end);
  return `${start.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' })} · ${start.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit' })}–${end.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit' })}`;
};

const createInitialWorkspace = (): MerkleStore => {
  const root = createScopeNode('Root Scope');
  const workflowScope = createScopeNode('Todo Workflow');
  const todoExpression = createExpressionNode('Todo Struct', 'Todo');

  todoExpression.metadata = {
    ...todoExpression.metadata,
    fields: [
      { id: `field-${createNodeId()}`, name: 'description', binding: { kind: 'hole' } },
      { id: `field-${createNodeId()}`, name: 'slug', binding: { kind: 'hole' } },
    ],
  };

  const defaultCalendarSlots = generateTimeSlots(5);
  root.metadata = {
    ...root.metadata,
    variables: [
      {
        id: `var-${createNodeId()}`,
        name: 'rootTicketTemplate',
        type: 'TodoTicket',
        scopeId: root.id,
      },
      {
        id: `var-${createNodeId()}`,
        name: 'My Budget',
        type: 'Budget',
        scopeId: root.id,
        resource: {
          kind: 'budget',
          label: 'Personal Budget',
          quantity: 250,
          unit: 'USD',
          consumable: true,
          origin: 'manual',
          resourceType: 'Budget',
        },
      },
      {
        id: `var-${createNodeId()}`,
        name: 'My Calendar',
        type: 'Time',
        scopeId: root.id,
        resource: {
          kind: 'time',
          label: 'Personal Calendar',
          quantity: defaultCalendarSlots.length,
          unit: 'hours',
          consumable: true,
          origin: 'manual',
          resourceType: 'Time',
          timeSlots: defaultCalendarSlots,
        },
      },
    ],
    tasks: [],
  };

  todoExpression.entries = gatherExpressionEntries(todoExpression.metadata.fields);
  workflowScope.entries = [
    {
      name: 'Todo Struct',
      ref: { kind: 'node', targetId: todoExpression.id },
    },
  ];

  root.entries = [
    {
      name: 'Todo Workflow',
      ref: { kind: 'node', targetId: workflowScope.id },
    },
  ];

  return {
    rootId: root.id,
    nodes: {
      [root.id]: root,
      [workflowScope.id]: workflowScope,
      [todoExpression.id]: todoExpression,
    },
  };
};

const findScopedVariables = (nodes: MerkleStore['nodes'], crumbs: ReadonlyArray<{ nodeId: ContentId }>): ScopedVariableInfo[] => {
  const scoped: ScopedVariableInfo[] = [];
  crumbs.forEach(crumb => {
    const node = nodes[crumb.nodeId];
    if (!isDirectory(node) || !isScopeMetadata(node.metadata)) {
      return;
    }
    scoped.push(
      ...node.metadata.variables.map(variable => ({
        ...variable,
        scopeLabel: node.metadata.label,
      })),
    );
  });
  return scoped;
};

const ScopeVariableList = ({
  variables,
  onInspect,
}: {
  variables: ScopedVariableInfo[];
  onInspect?: (variableId: string) => void;
}) => {
  if (variables.length === 0) {
    return <p className="text-xs text-foreground/50">No variables defined yet.</p>;
  }

  return (
    <div className="flex flex-wrap gap-2">
      {variables.map(variable => (
        <button
          key={variable.id}
          draggable
          onDragStart={event => {
            event.dataTransfer.setData(
              VARIABLE_DRAG_TYPE,
              JSON.stringify({ variableId: variable.id, scopeId: variable.scopeId }),
            );
            event.dataTransfer.effectAllowed = 'copy';
          }}
          className="rounded-full border border-white/10 bg-white/5 px-3 py-1 text-xs text-white hover:border-white/50"
          type="button"
          onClick={event => {
            event.preventDefault();
            onInspect?.(variable.id);
          }}
          onClick={event => {
            event.preventDefault();
            onInspect?.(variable.id);
          }}
        >
          <span className="font-semibold">{variable.name}</span>
          <span className="ml-2 text-foreground/40">({variable.scopeLabel})</span>
          {variable.resource && variable.resource.kind !== 'none' && (
            <span className="ml-2 rounded bg-black/40 px-2 py-0.5 text-[10px] uppercase tracking-widest text-foreground/60">
              {formatResourceSummary(variable.resource)}
            </span>
          )}
        </button>
      ))}
    </div>
  );
};

const InfoHint = ({ title, body }: { title: string; body: ReactNode }) => {
  const [open, setOpen] = useState(false);
  return (
    <span className="relative inline-flex items-center">
      <button
        type="button"
        className="ml-2 h-5 w-5 rounded-full border border-white/20 text-[10px] text-white/80 hover:border-white"
        onClick={() => setOpen(value => !value)}
        aria-label={`Toggle info about ${title}`}
      >
        ?
      </button>
      {open && (
        <div className="absolute left-0 top-6 z-10 w-64 rounded-xl border border-white/10 bg-black/80 p-3 text-xs text-white shadow-lg">
          <p className="font-semibold uppercase tracking-widest text-foreground/60">{title}</p>
          <div className="mt-1 text-foreground/80">{body}</div>
        </div>
      )}
    </span>
  );
};

interface CalendarModalProps {
  open: boolean;
  slots: CalendarSlot[];
  selectedSlotIds: Set<string>;
  onToggleSlot: (slotId: string) => void;
  onClose: () => void;
  onSave: () => void;
  title: string;
}

const CalendarModal = ({ open, slots, selectedSlotIds, onToggleSlot, onClose, onSave, title }: CalendarModalProps) => {
  if (!open) return null;
  const grouped = slots.reduce<Record<string, CalendarSlot[]>>((acc, slot) => {
    const day = new Date(slot.start).toLocaleDateString(undefined, { weekday: 'long', month: 'short', day: 'numeric' });
    acc[day] = acc[day] ?? [];
    acc[day].push(slot);
    return acc;
  }, {});

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 p-4">
      <div className="max-h-[90vh] w-full max-w-4xl overflow-y-auto rounded-3xl border border-white/20 bg-slate-950/95 p-6 shadow-2xl">
        <header className="mb-4 flex items-center justify-between">
          <div>
            <p className="text-xs uppercase tracking-[0.4em] text-foreground/50">Calendar allocation</p>
            <h3 className="text-2xl font-semibold text-white">{title}</h3>
          </div>
          <button
            type="button"
            onClick={onClose}
            className="rounded-full border border-white/20 px-3 py-1 text-xs uppercase tracking-[0.3em] text-white/70 hover:border-white/60"
          >
            Close
          </button>
        </header>
        <div className="grid gap-4 md:grid-cols-2">
          {Object.entries(grouped).map(([dayLabel, daySlots]) => (
            <section key={dayLabel} className="rounded-2xl border border-white/10 bg-white/5 p-3">
              <p className="text-sm font-semibold text-white">{dayLabel}</p>
              <div className="mt-2 grid grid-cols-2 gap-2 text-xs">
                {daySlots.map(slot => {
                  const isSelected = selectedSlotIds.has(slot.id);
                  return (
                    <button
                      key={slot.id}
                      type="button"
                      onClick={() => onToggleSlot(slot.id)}
                      className={`rounded-xl border px-2 py-1 text-left ${
                        isSelected
                          ? 'border-emerald-400 bg-emerald-500/20 text-emerald-100'
                          : 'border-white/10 bg-black/20 text-white/70 hover:border-white/40'
                      }`}
                    >
                      {formatSlotLabel(slot)}
                    </button>
                  );
                })}
                {daySlots.length === 0 && <p className="text-foreground/50">Fully allocated.</p>}
              </div>
            </section>
          ))}
        </div>
        <div className="mt-4 flex items-center justify-end gap-3">
          <button
            type="button"
            onClick={onSave}
            className="rounded-xl bg-emerald-500/80 px-4 py-2 text-xs font-semibold uppercase tracking-[0.4em] text-emerald-950 hover:bg-emerald-400"
          >
            Save selection
          </button>
        </div>
      </div>
    </div>
  );
};

interface ExpressionEditorCardProps {
  metadata: ExpressionMetadata;
  variables: ScopedVariableInfo[];
  onAddField: (name: string) => void;
  onSetBinding: (fieldId: string, binding: ExpressionBinding) => void;
  onSpawnChild: (fieldId: string, fieldName: string) => void;
  onNavigateToChild: (entryName: string) => void;
}

const ExpressionEditorCard = ({
  metadata,
  variables,
  onAddField,
  onSetBinding,
  onSpawnChild,
  onNavigateToChild,
}: ExpressionEditorCardProps) => {
  const [fieldDraft, setFieldDraft] = useState('');

  const variableById = useMemo(() => {
    const result = new Map<string, ScopedVariableInfo>();
    variables.forEach(variable => result.set(variable.id, variable));
    return result;
  }, [variables]);

  const handleAddField = (event: React.FormEvent) => {
    event.preventDefault();
    if (!fieldDraft.trim()) return;
    onAddField(fieldDraft.trim());
    setFieldDraft('');
  };

  const renderBinding = (field: ExpressionField) => {
    if (field.binding.kind === 'hole') {
      return <span className="text-rose-300 text-xs uppercase tracking-widest">Hole</span>;
    }
    if (field.binding.kind === 'variable') {
      const variable = variableById.get(field.binding.variableId);
      if (!variable) {
        return <span className="text-yellow-300 text-xs">Unknown variable</span>;
      }
      return (
        <span className="rounded-full border border-white/10 bg-white/5 px-3 py-1 text-xs text-white">
          {variable.name} · {variable.type}
        </span>
      );
    }
    if (field.binding.kind === 'expression') {
      return (
        <button
          type="button"
          onClick={() => onNavigateToChild(field.name)}
          className="rounded border border-white/20 px-3 py-1 text-xs text-foreground/80 hover:border-white/60"
        >
          Zoom into <span className="font-semibold">{field.name}</span>
        </button>
      );
    }
    return <span className="text-xs text-foreground/50">Empty</span>;
  };

  return (
    <div className="rounded-2xl border border-white/10 bg-black/20 p-4 shadow-inner shadow-black/30">
      <header className="mb-3 flex flex-col gap-1">
        <p className="text-xs uppercase tracking-[0.3em] text-foreground/50">Expression</p>
        <h4 className="text-lg font-semibold text-white">{metadata.label}</h4>
        <p className="text-sm text-foreground/60">Type: {metadata.typeName}</p>
      </header>

      <div className="space-y-3">
        {metadata.fields.map(field => (
          <div
            key={field.id}
            className="rounded-xl border border-dashed border-white/15 p-3"
            onDragOver={event => {
              if (event.dataTransfer.types.includes(VARIABLE_DRAG_TYPE)) {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'copy';
              }
            }}
            onDrop={event => {
              if (!event.dataTransfer.types.includes(VARIABLE_DRAG_TYPE)) return;
              event.preventDefault();
              const payload = event.dataTransfer.getData(VARIABLE_DRAG_TYPE);
              if (!payload) return;
              try {
                const { variableId } = JSON.parse(payload) as { variableId: string };
                onSetBinding(field.id, { kind: 'variable', variableId });
              } catch {
                // noop
              }
            }}
          >
            <div className="flex items-center justify-between">
              <div>
                <p className="text-xs uppercase tracking-widest text-foreground/50">Field</p>
                <p className="text-base text-white">{field.name}</p>
              </div>
              <div className="flex gap-2">
                <button
                  type="button"
                  className="rounded-full border border-white/10 px-3 py-1 text-xs text-foreground/70 hover:border-white/40"
                  onClick={() => onSetBinding(field.id, { kind: 'hole' })}
                >
                  Make hole
                </button>
                <button
                  type="button"
                  className="rounded-full border border-white/10 px-3 py-1 text-xs text-foreground/70 hover:border-white/40"
                  onClick={() => onSpawnChild(field.id, field.name)}
                >
                  Add constructor
                </button>
                <button
                  type="button"
                  className="rounded-full border border-white/10 px-3 py-1 text-xs text-foreground/70 hover:border-white/40"
                  onClick={() => onSetBinding(field.id, { kind: 'empty' })}
                >
                  Clear
                </button>
              </div>
              {scopeResourcePanel}

              {focusedVariablePanel}

              {isTaskQuery && (
                <>
                  <div className="flex items-center gap-2 pt-4">
                    <h4 className="text-sm uppercase tracking-[0.4em] text-foreground/50">Tasks</h4>
                    <InfoHint
                      title="Tasks"
                      body="Pending tasks are typed goals (Σ/Π variables) waiting for values. Drag resources into their arguments, or mark them complete to mint new resources for the scope."
                    />
                    <span className="rounded-full border border-white/10 px-2 py-0.5 text-[10px] uppercase tracking-[0.3em] text-foreground/60">
                      Pending: {pendingTodos.length}
                    </span>
                  </div>
                  <form
                    className="space-y-2 rounded-2xl border border-white/10 bg-black/20 p-3"
                    onSubmit={event => {
                      event.preventDefault();
                      if (!taskDraft.title.trim()) return;
                      addTask(
                        directoryNode!.id,
                        taskDraft.title.trim(),
                        taskDraft.description.trim(),
                        taskDraft.requiredResourceIds,
                        taskDraft.requiredFacts,
                      );
                      setTaskDraft({ title: '', description: '', requiredResourceIds: [], requiredFacts: [], factInput: '' });
                    }}
                  >
                    <input
                      value={taskDraft.title}
                      onChange={event => setTaskDraft(current => ({ ...current, title: event.target.value }))}
                      placeholder="Task title"
                      className="w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                    />
                    <textarea
                      value={taskDraft.description}
                      onChange={event => setTaskDraft(current => ({ ...current, description: event.target.value }))}
                      placeholder="Description"
                      className="w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                      rows={2}
                    />
                    <label className="text-xs uppercase tracking-[0.3em] text-foreground/50">Requires resources</label>
                    <div className="flex flex-wrap gap-2">
                      {availableVariablesForDrop
                        .filter(variable => variable.resource)
                        .map(variable => {
                          const checked = taskDraft.requiredResourceIds.includes(variable.id);
                          return (
                            <button
                              key={variable.id}
                              type="button"
                              onClick={() =>
                                setTaskDraft(current => ({
                                  ...current,
                                  requiredResourceIds: checked
                                    ? current.requiredResourceIds.filter(id => id !== variable.id)
                                    : [...current.requiredResourceIds, variable.id],
                                }))
                              }
                              className={`rounded-full border px-3 py-1 text-xs ${
                                checked ? 'border-emerald-400 bg-emerald-500/20 text-emerald-100' : 'border-white/15 bg-white/5 text-white/70'
                              }`}
                            >
                              {variable.name}
                            </button>
                          );
                        })}
                      {availableVariablesForDrop.filter(variable => variable.resource).length === 0 && (
                        <span className="text-xs text-foreground/50">No inheritable resources yet.</span>
                      )}
                    </div>
                    <button
                      type="submit"
                      className="w-full rounded-xl bg-indigo-500/80 px-4 py-2 text-xs font-semibold uppercase tracking-widest text-indigo-950 hover:bg-indigo-400"
                    >
                      Add task
                    </button>
                  </form>

                  <div className="space-y-3">
                    {scopeMetadata.tasks.length === 0 && <p className="text-xs text-foreground/50">No tasks yet.</p>}
                    {scopeMetadata.tasks.map(task => (
                      <ScopeTaskCard
                        key={task.id}
                        task={task}
                        variables={availableVariablesForDrop}
                        onComplete={produced => completeTask(directoryNode!.id, task.id, produced)}
                        hasFact={hasFactProof}
                        onRequireFact={requestFactTask}
                      />
                    ))}
                  </div>
                </>
              )}

              {inlineResourceCards}
            </div>
            <div className="mt-2">{renderBinding(field)}</div>
            <p className="mt-2 text-xs text-foreground/50">
              Drag a variable from the stack to bind this field. Use &quot;Add constructor&quot; to descend into a nested scope.
            </p>
          </div>
        ))}
      </div>

      <form onSubmit={handleAddField} className="mt-4 flex gap-3">
        <input
          value={fieldDraft}
          onChange={event => setFieldDraft(event.target.value)}
          placeholder="New field name"
          className="flex-1 rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
        />
        <button
          type="submit"
          className="rounded-xl bg-white/10 px-4 py-2 text-xs font-semibold uppercase tracking-widest text-white hover:bg-white/20"
        >
          Add field
        </button>
      </form>
    </div>
  );
};

interface ScopeTaskCardProps {
  task: ScopeTask;
  variables: ScopedVariableInfo[];
  onComplete: (produced: ResourceMetadata | undefined) => void;
  hasFact: (factType: string) => boolean;
  onRequireFact: (factType: string, task: ScopeTask) => void;
}

const ScopeTaskCard = ({ task, variables, onComplete, hasFact, onRequireFact }: ScopeTaskCardProps) => {
  const [resourceForm, setResourceForm] = useState({
    kind: 'none' as ResourceKind,
    label: '',
    quantity: 0,
    unit: 'unit',
    consumable: false,
    factType: '',
  });

  return (
    <div className="rounded-2xl border border-white/10 bg-black/20 p-4">
      <header className="flex flex-col gap-1 md:flex-row md:items-center md:justify-between">
        <div>
          <p className="text-xs uppercase tracking-[0.3em] text-foreground/50">Task</p>
          <h4 className="text-lg font-semibold text-white">{task.title}</h4>
          {task.description && <p className="text-sm text-foreground/60">{task.description}</p>}
        </div>
        <span
          className={`rounded-full px-3 py-1 text-xs uppercase tracking-widest ${
            task.status === 'completed'
              ? 'bg-emerald-500/30 text-emerald-100 border border-emerald-500/40'
              : 'bg-white/10 text-white/70 border border-white/20'
          }`}
        >
          {task.status}
        </span>
      </header>
      <div className="mt-3 space-y-2 text-sm">
        <p className="text-xs uppercase tracking-[0.4em] text-foreground/50">Required resources</p>
        <div className="flex flex-wrap gap-2">
          {task.requiredResourceIds.length === 0 && <span className="text-xs text-foreground/50">None</span>}
          {task.requiredResourceIds.map(resourceId => {
            const variable = variables.find(entry => entry.id === resourceId);
            if (!variable) return null;
            return (
              <span
                key={resourceId}
                className="rounded-full border border-white/10 bg-white/5 px-3 py-1 text-xs text-white"
              >
                {variable.name}
                {variable.resource && <span className="ml-2 text-foreground/50">{formatResourceSummary(variable.resource)}</span>}
              </span>
            );
          })}
        </div>
        {task.requiredFacts.length > 0 && (
          <div className="text-xs text-foreground/60">
            <p className="text-[10px] uppercase tracking-[0.3em] text-foreground/50">Required facts</p>
            <div className="mt-1 space-y-1">
              {task.requiredFacts.map(fact => {
                const satisfied = hasFact(fact);
                return (
                  <div
                    key={fact}
                    className="flex items-center justify-between rounded border border-white/10 px-2 py-1 text-white"
                  >
                    <span>{fact}</span>
                    {satisfied ? (
                      <span className="text-emerald-300 text-[10px] uppercase tracking-[0.3em]">available</span>
                    ) : (
                      <button
                        type="button"
                        onClick={() => onRequireFact(fact, task)}
                        className="rounded-full border border-white/20 px-2 py-0.5 text-[10px] uppercase tracking-[0.3em] text-white/70 hover:border-white/50"
                      >
                        request proof
                      </button>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
        )}
      </div>
      {task.status === 'pending' && (
        <div className="mt-4 space-y-2">
          <p className="text-xs uppercase tracking-[0.4em] text-foreground/50">Output resource (optional)</p>
          <div className="grid gap-2 md:grid-cols-2">
            <select
              value={resourceForm.kind}
              onChange={event => setResourceForm(current => ({ ...current, kind: event.target.value as ResourceKind }))}
              className="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
            >
              <option value="none">None</option>
              <option value="budget">Budget</option>
              <option value="time">Time</option>
              <option value="asset">Asset</option>
              <option value="custom">Custom</option>
              <option value="fact">Fact</option>
            </select>
            {resourceForm.kind !== 'none' && (
              <input
                value={resourceForm.label}
                onChange={event => setResourceForm(current => ({ ...current, label: event.target.value }))}
                placeholder="Resource label"
                className="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
              />
            )}
          </div>
          {resourceForm.kind !== 'none' && (
            <div className="grid gap-2 md:grid-cols-3">
              <input
                type="number"
                min={0}
                value={resourceForm.quantity}
                onChange={event => setResourceForm(current => ({ ...current, quantity: Number(event.target.value) }))}
                placeholder="Quantity"
                className="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
              />
              {(resourceForm.kind === 'asset' || resourceForm.kind === 'custom') && (
                <input
                  value={resourceForm.unit}
                  onChange={event => setResourceForm(current => ({ ...current, unit: event.target.value }))}
                  placeholder="Unit"
                  className="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                />
              )}
              {resourceForm.kind === 'fact' && (
                <input
                  value={resourceForm.factType}
                  onChange={event => setResourceForm(current => ({ ...current, factType: event.target.value }))}
                  placeholder="Fact type"
                  className="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                />
              )}
              <label className="flex items-center gap-2 text-xs uppercase tracking-[0.3em] text-foreground/50">
                <input
                  type="checkbox"
                  checked={resourceForm.consumable}
                  onChange={event => setResourceForm(current => ({ ...current, consumable: event.target.checked }))}
                  className="accent-emerald-500"
                />
                Consumable
              </label>
            </div>
          )}
          <button
            type="button"
            onClick={() =>
              onComplete(
                resourceForm.kind === 'none'
                  ? undefined
                  : {
                      kind: resourceForm.kind,
                      label: resourceForm.label || `${task.title} output`,
                      quantity: resourceForm.quantity,
                      unit:
                        resourceForm.kind === 'budget'
                          ? 'USD'
                          : resourceForm.kind === 'time'
                            ? 'hours'
                            : resourceForm.unit || 'unit',
                      consumable: resourceForm.kind === 'fact' ? false : resourceForm.consumable,
                      resourceType: resourceForm.label || task.title,
                      factType:
                        resourceForm.kind === 'fact'
                          ? resourceForm.factType || resourceForm.label || task.title
                          : undefined,
                    },
              )
            }
            className="w-full rounded-xl bg-emerald-500/80 px-4 py-2 text-xs font-semibold uppercase tracking-widest text-emerald-950 hover:bg-emerald-400"
          >
            Save output & complete
          </button>
        </div>
      )}
      {task.status === 'completed' && task.producedResources.length > 0 && (
        <div className="mt-3 text-xs text-foreground/60">
          <p className="uppercase tracking-[0.3em] text-foreground/50">Produced</p>
          <ul className="mt-1 space-y-1">
            {task.producedResources.map(entry => (
              <li key={entry.id} className="rounded border border-white/10 px-2 py-1 text-foreground/70">
                {formatResourceSummary(entry.resource)}
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
};

const FosScopeBuilder = () => {
  const [store, setStore] = useState<MerkleStore>(() => createInitialWorkspace());
  const [path, setPath] = useState<string[]>([]);

  const navigator = useMemo(() => new MerkleNavigator(store), [store]);
  const resolved = useMemo(() => navigator.resolvePath(path), [navigator, path]);
  const activeNode = resolved.activeNode;
  const directoryNode = isDirectory(activeNode) ? activeNode : null;
  const scopeMetadata = directoryNode && isScopeMetadata(directoryNode.metadata) ? directoryNode.metadata : null;
  const expressionMetadata =
    directoryNode && isExpressionMetadata(directoryNode.metadata) ? directoryNode.metadata : null;
  const parentScopeId: ContentId | null = resolved.crumbs.length > 1
    ? (resolved.crumbs[resolved.crumbs.length - 2].nodeId as ContentId)
    : null;

  const scopedVariables = useMemo(
    () => findScopedVariables(store.nodes, resolved.crumbs),
    [store.nodes, resolved.crumbs],
  );

  const [variableDraft, setVariableDraft] = useState({ name: '', type: '' });
  const [resourceDraft, setResourceDraft] = useState<{
    kind: ResourceKind;
    quantity: number;
    unit: string;
    label: string;
    consumable: boolean;
    sourceVariableId?: string;
    resourceType?: string;
    timeSlots: CalendarSlot[];
    factType?: string;
  }>({
    kind: 'none',
    quantity: 0,
    unit: '',
    label: '',
    consumable: true,
    sourceVariableId: undefined,
    resourceType: 'Resource',
    timeSlots: [],
    factType: '',
  });
  const [personDraft, setPersonDraft] = useState({
    name: '',
    budget: 100,
    hours: 10,
  });
  const [expressionDraft, setExpressionDraft] = useState({ label: '', typeName: '' });
  const [childScopeDraft, setChildScopeDraft] = useState('');
  const [taskDraft, setTaskDraft] = useState({ title: '', description: '', requiredResourceIds: [] as string[], requiredFacts: [] as string[], factInput: '' });
  const [queryText, setQueryText] = useState('');
  const [queryResults, setQueryResults] = useState<Array<{ id: string; label: string; details: string }>>([]);
  const [activeQuery, setActiveQuery] = useState('');
  const [activeQueryLabel, setActiveQueryLabel] = useState('');
  const [calendarModal, setCalendarModal] = useState<{
    open: boolean;
    parent?: ScopedVariableInfo;
    selectedIds: string[];
    onSave?: (slots: CalendarSlot[], parent: ScopedVariableInfo) => void;
  }>({ open: false, parent: undefined, selectedIds: [] });
  const [focusedVariableId, setFocusedVariableId] = useState<string | null>(null);
  const [budgetAllocationDraft, setBudgetAllocationDraft] = useState({ name: '', amount: 0 });
  const [typeDraft, setTypeDraft] = useState('');
  const [newTodoDraft, setNewTodoDraft] = useState({ title: '', description: '' });
  const [newTypedVarDraft, setNewTypedVarDraft] = useState({ name: '', label: '' });
  const [newAgentDraft, setNewAgentDraft] = useState({ name: '', budget: 100, hours: 10 });

  const updateNode = useCallback(
    (nodeId: ContentId, updater: (node: DirectoryNode) => DirectoryNode) => {
      setStore(prev => {
        const node = prev.nodes[nodeId];
        if (!isDirectory(node)) return prev;
        const updated = updater(node);
        return { ...prev, nodes: { ...prev.nodes, [nodeId]: updated } };
      });
    },
    [],
  );

  const addVariable = useCallback(
    (scopeId: ContentId, name: string, type: string, resource?: ResourceMetadata) => {
      setStore(prev => {
        const scopeNode = prev.nodes[scopeId];
        if (!isDirectory(scopeNode) || !isScopeMetadata(scopeNode.metadata)) {
          return prev;
        }
        const metadata = cloneScopeMetadata(scopeNode.metadata);
        let variableResource = resource && resource.kind !== 'none'
          ? { ...resource, origin: resource.origin ?? 'manual' }
          : undefined;
        if (variableResource?.kind === 'time') {
          variableResource = {
            ...variableResource,
            timeSlots: variableResource.timeSlots ?? [],
            quantity: variableResource.timeSlots ? sumSlotHours(variableResource.timeSlots) : variableResource.quantity,
            unit: 'hours',
            resourceType: variableResource.resourceType ?? 'Time',
          };
        }
        const variable: ScopeVariable = {
          id: `var-${createNodeId()}`,
          name,
          type,
          scopeId,
          resource: variableResource,
        };
        metadata.variables.push(variable);

        let nextNodes: Record<ContentId, MerkleNode> = {
          ...prev.nodes,
          [scopeId]: { ...scopeNode, metadata },
        };

        if (resource?.sourceVariableId && resource.quantity > 0) {
          const adjusted = adjustVariableResource(nextNodes, resource.sourceVariableId, -resource.quantity, {
            timeSlots: resource.timeSlots,
          });
          if (!adjusted) {
            // Failed to adjust resource; revert.
            return prev;
          }
          nextNodes = adjusted;
        }

        return { ...prev, nodes: nextNodes };
      });
    },
    [],
  );

  const addExpression = useCallback(
    (scopeId: ContentId, label: string, typeName: string) => {
      setStore(prev => {
        const scopeNode = prev.nodes[scopeId];
        if (!isDirectory(scopeNode) || !isScopeMetadata(scopeNode.metadata)) {
          return prev;
        }

        const expressionNode = createExpressionNode(label, typeName);
        const entryName = sanitizeEntryName(scopeNode.entries, label);
        const updatedScope: DirectoryNode = {
          ...scopeNode,
          entries: [
            ...scopeNode.entries,
            { name: entryName, ref: { kind: 'node', targetId: expressionNode.id } },
          ],
        };

        return {
          ...prev,
          nodes: {
            ...prev.nodes,
            [scopeId]: updatedScope,
            [expressionNode.id]: expressionNode,
          },
        };
      });
    },
    [],
  );

  const addChildScope = useCallback((scopeId: ContentId, label: string) => {
    setStore(prev => {
      const scopeNode = prev.nodes[scopeId];
      if (!isDirectory(scopeNode) || !isScopeMetadata(scopeNode.metadata)) {
        return prev;
      }
      const childScope = createScopeNode(label);
      const entryName = sanitizeEntryName(scopeNode.entries, label);
      const updatedScope: DirectoryNode = {
        ...scopeNode,
        entries: [
          ...scopeNode.entries,
          { name: entryName, ref: { kind: 'node', targetId: childScope.id } },
        ],
      };
      return {
        ...prev,
        nodes: {
          ...prev.nodes,
          [scopeId]: updatedScope,
          [childScope.id]: childScope,
        },
      };
    });
  }, []);

  const addPerson = useCallback((name: string, budget: number, hours: number) => {
    setStore(prev => {
      const rootNode = prev.nodes[prev.rootId];
      if (!isDirectory(rootNode) || !isScopeMetadata(rootNode.metadata)) {
        return prev;
      }
      const agentScope = createScopeNode(`Agent: ${name}`);
      const entryName = sanitizeEntryName(rootNode.entries, agentScope.metadata.label);
      const rootUpdated: DirectoryNode = {
        ...rootNode,
        entries: [
          ...rootNode.entries,
          { name: entryName, ref: { kind: 'node', targetId: agentScope.id } },
        ],
      };
      const agentMetadata = cloneScopeMetadata(agentScope.metadata);
      const baseSlots = generateTimeSlots(5);
      const timeSlotCount = Math.min(baseSlots.length, Math.max(1, Math.floor(hours)));
      agentMetadata.variables.push(
        {
          id: `var-${createNodeId()}`,
          name: `${name} Budget`,
          type: 'Budget',
          scopeId: agentScope.id,
          resource: {
            kind: 'budget',
            label: `${name} Budget`,
            quantity: budget,
            unit: 'USD',
            consumable: true,
            origin: 'manual',
            resourceType: 'Budget',
          },
        },
        {
          id: `var-${createNodeId()}`,
          name: `${name} Calendar`,
          type: 'Time',
          scopeId: agentScope.id,
          resource: {
            kind: 'time',
            label: `${name} Calendar`,
            quantity: timeSlotCount,
            unit: 'hours',
            consumable: true,
            origin: 'manual',
            resourceType: 'Time',
            timeSlots: baseSlots.slice(0, timeSlotCount),
          },
        },
      );
      const agentScopeWithVars: DirectoryNode = {
        ...agentScope,
        metadata: agentMetadata,
      };

      return {
        ...prev,
        nodes: {
          ...prev.nodes,
          [prev.rootId]: rootUpdated,
          [agentScope.id]: agentScopeWithVars,
        },
      };
    });
  }, []);

  const addFieldToExpression = useCallback((expressionId: ContentId, name: string) => {
    updateNode(expressionId, node => {
      if (!isExpressionMetadata(node.metadata)) return node;
      const metadata = cloneExpressionMetadata(node.metadata);
      metadata.fields.push({
        id: `field-${createNodeId()}`,
        name,
        binding: { kind: 'empty' },
      });
      return { ...node, metadata, entries: gatherExpressionEntries(metadata.fields) };
    });
  }, [updateNode]);

  const addTask = useCallback(
    (scopeId: ContentId, title: string, description: string, requiredResourceIds: string[], requiredFacts: string[] = []) => {
      setStore(prev => {
        const scopeNode = prev.nodes[scopeId];
        if (!isDirectory(scopeNode) || !isScopeMetadata(scopeNode.metadata)) {
          return prev;
        }
        const metadata = cloneScopeMetadata(scopeNode.metadata);
        metadata.tasks.push({
          id: `task-${createNodeId()}`,
          title,
          description,
          requiredResourceIds,
          requiredFacts,
          status: 'pending',
          producedResources: [],
        });
        return {
          ...prev,
          nodes: {
            ...prev.nodes,
            [scopeId]: { ...scopeNode, metadata },
          },
        };
      });
    },
    [],
  );

  const setFieldBinding = useCallback(
    (expressionId: ContentId, fieldId: string, binding: ExpressionBinding) => {
      updateNode(expressionId, node => {
        if (!isExpressionMetadata(node.metadata)) return node;
        const metadata = cloneExpressionMetadata(node.metadata);
        const field = metadata.fields.find(current => current.id === fieldId);
        if (!field) return node;
        field.binding = binding;
        return {
          ...node,
          metadata,
          entries: gatherExpressionEntries(metadata.fields),
        };
      });
    },
    [updateNode],
  );

  const spawnFieldExpression = useCallback(
    (expressionId: ContentId, fieldId: string, fieldName: string) => {
      setStore(prev => {
        const expressionNode = prev.nodes[expressionId];
        if (!isDirectory(expressionNode) || !isExpressionMetadata(expressionNode.metadata)) {
          return prev;
        }
        const nestedExpression = createExpressionNode(`${expressionNode.metadata.label}.${fieldName}`, 'Nested');
        const metadata = cloneExpressionMetadata(expressionNode.metadata);
        const field = metadata.fields.find(current => current.id === fieldId);
        if (!field) return prev;
        field.binding = { kind: 'expression', nodeId: nestedExpression.id };
        const updatedExpression: DirectoryNode = {
          ...expressionNode,
          metadata,
          entries: gatherExpressionEntries(metadata.fields),
        };

        return {
          ...prev,
          nodes: {
            ...prev.nodes,
            [expressionId]: updatedExpression,
            [nestedExpression.id]: nestedExpression,
          },
        };
      });
    },
    [],
  );

  const updateVariableType = useCallback((variableId: string, nextType: string) => {
    setStore(prev => {
      const location = findVariableLocation(prev.nodes, variableId);
      if (!location) return prev;
      const { scopeId } = location;
      const scopeNode = prev.nodes[scopeId];
      if (!isDirectory(scopeNode) || !isScopeMetadata(scopeNode.metadata)) return prev;
      const metadata = cloneScopeMetadata(scopeNode.metadata);
      const target = metadata.variables.find(entry => entry.id === variableId);
      if (!target) return prev;
      target.type = nextType;
      return {
        ...prev,
        nodes: {
          ...prev.nodes,
          [scopeId]: { ...scopeNode, metadata },
        },
      };
    });
  }, []);

  const releaseVariable = useCallback((variableId: string) => {
    setFocusedVariableId(prev => (prev === variableId ? null : prev));
    setStore(prev => {
      const location = findVariableLocation(prev.nodes, variableId);
      if (!location) return prev;
      const { scopeId, variable } = location;
      const scopeNode = prev.nodes[scopeId];
      if (!isDirectory(scopeNode) || !isScopeMetadata(scopeNode.metadata)) return prev;
      if (!variable.resource?.sourceVariableId) return prev;
      const metadata = cloneScopeMetadata(scopeNode.metadata);
      metadata.variables = metadata.variables.filter(entry => entry.id !== variableId);
      let nextNodes: Record<ContentId, MerkleNode> = {
        ...prev.nodes,
        [scopeId]: { ...scopeNode, metadata },
      };
      const adjusted = adjustVariableResource(
        nextNodes,
        variable.resource.sourceVariableId,
        variable.resource.quantity,
        { timeSlots: variable.resource.timeSlots },
      );
      if (!adjusted) {
        return prev;
      }
      nextNodes = adjusted;
      return { ...prev, nodes: nextNodes };
    });
  }, []);

  const completeTask = useCallback(
    (scopeId: ContentId, taskId: string, producedResource?: ResourceMetadata) => {
      setStore(prev => {
        const scopeNode = prev.nodes[scopeId];
        if (!isDirectory(scopeNode) || !isScopeMetadata(scopeNode.metadata)) {
          return prev;
        }
        const metadata = cloneScopeMetadata(scopeNode.metadata);
        const task = metadata.tasks.find(entry => entry.id === taskId);
        if (!task || task.status === 'completed') return prev;
        task.status = 'completed';
        if (producedResource && producedResource.kind !== 'none') {
          const resource: ResourceMetadata = {
            ...producedResource,
            origin: 'task',
            lockedToScopeId: scopeId,
            releasedToParent: false,
            resourceType: producedResource.resourceType ?? 'Resource',
          };
          const variableName = producedResource.label || `${task.title} output`;
          metadata.variables.push({
            id: `var-${createNodeId()}`,
            name: variableName,
            type: producedResource.resourceType ?? 'Resource',
            scopeId,
            resource,
          });
          task.producedResources.push({ id: `prod-${createNodeId()}`, resource });
        }
        return {
          ...prev,
          nodes: {
            ...prev.nodes,
            [scopeId]: { ...scopeNode, metadata },
          },
        };
      });
    },
    [],
  );

  const completeScope = useCallback(
    (scopeId: ContentId, parentId: ContentId | null) => {
      if (!parentId) return;
      setStore(prev => {
        const scopeNode = prev.nodes[scopeId];
        const parentNode = prev.nodes[parentId];
        if (!isDirectory(scopeNode) || !isScopeMetadata(scopeNode.metadata) || !isDirectory(parentNode) || !isScopeMetadata(parentNode.metadata)) {
          return prev;
        }
        const scopeMetadata = cloneScopeMetadata(scopeNode.metadata);
        const parentMetadata = cloneScopeMetadata(parentNode.metadata);
        scopeMetadata.completed = true;
        scopeMetadata.variables.forEach(variable => {
          const resource = variable.resource;
          if (resource && resource.origin === 'task' && !resource.releasedToParent) {
            parentMetadata.variables.push({
              id: `var-${createNodeId()}`,
              name: variable.name,
              type: variable.type,
              scopeId: parentId,
              resource: { ...resource, lockedToScopeId: undefined, releasedToParent: true, origin: 'imported' },
            });
            resource.releasedToParent = true;
          }
        });
        return {
          ...prev,
          nodes: {
            ...prev.nodes,
            [scopeId]: { ...scopeNode, metadata: scopeMetadata },
            [parentId]: { ...parentNode, metadata: parentMetadata },
          },
        };
      });
    },
    [],
  );

  const currentEntries: DirectoryEntry[] = directoryNode?.entries ?? [];

  const handleEntryNavigate = (entryName: string) => {
    setPath(prev => [...prev, entryName]);
  };

  const handleCrumbClick = (index: number) => {
    setPath(prev => prev.slice(0, index));
  };

  const availableVariablesForDrop = scopeMetadata ? scopedVariables : scopedVariables;
  const parentResourceVariable = resourceDraft.sourceVariableId
    ? availableVariablesForDrop.find(variable => variable.id === resourceDraft.sourceVariableId)
    : undefined;
  const scopeTasks = scopeMetadata?.tasks ?? [];
  const pendingTodos = scopeTasks.filter(task => task.status === 'pending');
  const calendarSelection = new Set(calendarModal.selectedIds);
  const calendarModalSlots =
    calendarModal.parent?.resource?.kind === 'time' ? calendarModal.parent.resource.timeSlots ?? [] : [];
  const focusedVariable = focusedVariableId
    ? availableVariablesForDrop.find(variable => variable.id === focusedVariableId) ?? null
    : null;
  const childAllocations = scopeMetadata
    ? scopeMetadata.variables.filter(variable => variable.resource?.sourceVariableId === focusedVariable?.id)
    : [];
  const lowerQuery = activeQuery.toLowerCase();
  const isTaskQuery = lowerQuery.includes('task') || lowerQuery === 'todo';
  const isAgentQuery = lowerQuery.includes('agent');
  const showExpressionForm = !activeQuery || lowerQuery.includes('expression') || lowerQuery.includes('type');
  const showResourceOverview =
    Boolean(activeQuery) && ['budget', 'time', 'resource', 'fact', 'calendar'].some(key => lowerQuery.includes(key));
  const showInlineResources = Boolean(scopeMetadata) && lowerQuery.includes('resource');
  const inlineResourceCards =
    showInlineResources && scopeMetadata
      ? scopeMetadata.variables
          .filter(variable => variable.resource)
          .map(variable => (
            <div
              key={variable.id}
              className="rounded-2xl border border-white/10 bg-white/5 p-3 text-sm text-white cursor-pointer hover:border-white/30"
              onClick={() => setFocusedVariableId(variable.id)}
            >
              <div className="flex items-center justify-between gap-2">
                <div>
                  <p className="font-semibold">{variable.name}</p>
                  <p className="text-xs text-foreground/60">{variable.type}</p>
                </div>
                <span className="rounded-full border border-white/10 px-3 py-1 text-xs text-foreground/60">
                  {formatResourceSummary(variable.resource)}
                </span>
              </div>
            </div>
          ))
      : null;
  const hasFactProof = useCallback(
    (factType: string) =>
      availableVariablesForDrop.some(
        variable =>
          variable.resource?.kind === 'fact' &&
          variable.resource.factType?.toLowerCase() === factType.toLowerCase(),
      ),
    [availableVariablesForDrop],
  );

  const requestFactTask = useCallback(
    (factType: string, parentTask: ScopeTask) => {
      if (!directoryNode) return;
      addTask(directoryNode.id, `Establish ${factType}`, `Required for ${parentTask.title}`, [], [factType]);
    },
    [addTask, directoryNode],
  );

  useEffect(() => {
    if (focusedVariable && !availableVariablesForDrop.some(variable => variable.id === focusedVariable.id)) {
      setFocusedVariableId(null);
    }
  }, [availableVariablesForDrop, focusedVariable]);

  useEffect(() => {
    setBudgetAllocationDraft({ name: '', amount: 0 });
    setTypeDraft(focusedVariable?.type ?? '');
  }, [focusedVariable?.id, focusedVariable?.type]);

  const openCalendarSelector = (
    parent: ScopedVariableInfo,
    initialIds: string[],
    onSave: (slots: CalendarSlot[], parent: ScopedVariableInfo) => void,
  ) => {
    if (!parent.resource || parent.resource.kind !== 'time') return;
    const parentSlots = parent.resource.timeSlots ?? [];
    if (parentSlots.length === 0) return;
    setCalendarModal({
      open: true,
      parent,
      selectedIds: initialIds,
      onSave,
    });
  };

  const openCalendarPicker = () => {
    if (!parentResourceVariable) return;
    openCalendarSelector(parentResourceVariable, resourceDraft.timeSlots.map(slot => slot.id), (slots, parent) => {
      setResourceDraft(current => ({
        ...current,
        timeSlots: slots,
        quantity: sumSlotHours(slots),
        unit: 'hours',
        label: current.label || parent.resource?.label || 'Sub calendar',
        resourceType: 'Time',
      }));
    });
  };

  const openCalendarForVariable = (variable: ScopedVariableInfo) => {
    if (!variable.resource || variable.resource.kind !== 'time') return;
    openCalendarSelector(variable, [], (slots, parent) => {
      if (slots.length === 0) return;
      const name = `${parent.name} slice`;
      addVariable(directoryNode!.id, name, 'Time', {
        kind: 'time',
        label: name,
        quantity: sumSlotHours(slots),
        unit: 'hours',
        consumable: true,
        sourceVariableId: parent.id,
        timeSlots: slots,
        resourceType: 'Time',
      });
    });
  };

  const handleCalendarToggle = (slotId: string) => {
    setCalendarModal(current => ({
      ...current,
      selectedIds: current.selectedIds.includes(slotId)
        ? current.selectedIds.filter(id => id !== slotId)
        : [...current.selectedIds, slotId],
    }));
  };

  const handleCalendarSave = () => {
    if (!calendarModal.parent || calendarModal.parent.resource?.kind !== 'time') {
      setCalendarModal({ open: false, selectedIds: [], parent: undefined, onSave: undefined });
      return;
    }
    const parentSlots = calendarModal.parent.resource.timeSlots ?? [];
    const selectedSlots = parentSlots.filter(slot => calendarModal.selectedIds.includes(slot.id));
    if (calendarModal.onSave) {
      calendarModal.onSave(selectedSlots, calendarModal.parent);
    }
    setCalendarModal({ open: false, selectedIds: [], parent: undefined, onSave: undefined });
  };

  return (
    <div className="rounded-3xl border border-white/10 bg-slate-900/50 p-6 shadow-2xl shadow-black/40 backdrop-blur">
      <header className="mb-6 flex items-center justify-end">
        <InfoHint
          title="What is this?"
          body="Everything here is a scope. Breadcrumbs let you zoom, and the cards update based on the current context."
        />
      </header>

      <div className="mb-4 flex flex-wrap gap-2">
        {resolved.crumbs.map((crumb, index) => (
          <button
            key={crumb.nodeId}
            type="button"
            onClick={() => handleCrumbClick(index)}
            className={`rounded-full px-3 py-1 text-xs ${
              index === resolved.crumbs.length - 1
                ? 'bg-emerald-500/30 text-white'
                : 'bg-white/5 text-foreground/70 hover:bg-white/10'
            }`}
          >
            {crumb.label}
          </button>
        ))}
      </div>

      <div className="grid gap-6 lg:grid-cols-[320px,1fr]">
        <aside className="space-y-4 rounded-2xl border border-white/10 bg-black/20 p-4">
          <div className="rounded-2xl border border-white/10 bg-white/5 p-3 text-sm text-white">
            <div className="flex items-center justify-between">
              <p className="text-xs uppercase tracking-[0.3em] text-foreground/50">Queries</p>
              <InfoHint
                title="Type queries"
                body="Describe the type of thing you want (Todo, Fact, Budget, etc.). The planner matches variables/tasks that inhabit that type, just like a Datalog query."
              />
            </div>
            <input
              value={queryText}
              onChange={event => setQueryText(event.target.value)}
              placeholder="Type name (e.g. Todo)"
              className="mt-2 w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-xs text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
            />
            <div className="mt-2 flex gap-2">
            <button
              type="button"
              onClick={() => {
                const original = queryText.trim();
                const normalized = original.toLowerCase();
                if (!normalized) return;
                const results: Array<{ id: string; label: string; details: string }> = [];
                scopeMetadata?.tasks.forEach(task => {
                  if (task.status === 'pending' && (task.title.toLowerCase().includes(normalized) || normalized === 'todo')) {
                    results.push({ id: task.id, label: task.title, details: task.description ?? '' });
                  }
                });
                scopeMetadata?.variables.forEach(variable => {
                  const summary = formatResourceSummary(variable.resource) ?? variable.type;
                  if (variable.type.toLowerCase().includes(normalized) || summary?.toLowerCase().includes(normalized)) {
                    results.push({
                      id: variable.id,
                      label: variable.name,
                      details: summary,
                    });
                  }
                  if (variable.resource?.kind === 'fact' && variable.resource.factType?.toLowerCase().includes(normalized)) {
                    results.push({
                      id: variable.id,
                      label: variable.resource.factType ?? variable.name,
                      details: 'Fact witness',
                    });
                  }
                });
                setActiveQuery(normalized);
                setActiveQueryLabel(original);
                setQueryResults(results);
              }}
              className="w-full rounded-xl bg-emerald-500/70 px-3 py-2 text-[10px] font-semibold uppercase tracking-[0.3em] text-emerald-950 hover:bg-emerald-400"
            >
              Search
            </button>
              {queryText.trim() && (
                <button
                  type="button"
                  onClick={() => {
                    const normalizedLabel = queryText.trim();
                    const normalized = normalizedLabel.toLowerCase();
                    setActiveQuery(normalized);
                    setActiveQueryLabel(normalizedLabel);
                    setQueryResults([]);
                  }}
                  className="w-full rounded-xl border border-white/20 px-3 py-2 text-[10px] font-semibold uppercase tracking-[0.3em] text-white hover:border-white/40"
                >
                  Add new {queryText}
                </button>
              )}
            </div>
            <div className="mt-3 max-h-40 space-y-1 overflow-y-auto text-xs text-foreground/70">
              {queryResults.length === 0 && <p>No results yet. Enter a type to search.</p>}
              {queryResults.map(result => (
                <button
                  key={result.id}
                  type="button"
                  onClick={() => {
                    if (scopeMetadata?.tasks.some(task => task.id === result.id)) {
                      setTaskDraft(current => ({ ...current, title: result.label }));
                    } else {
                      setFocusedVariableId(result.id);
                    }
                  }}
                  className="w-full rounded border border-white/10 px-2 py-1 text-left text-white hover:border-white/40"
                >
                  <p className="font-semibold">{result.label}</p>
                  <p className="text-[10px] uppercase tracking-[0.3em] text-foreground/50">{result.details}</p>
                </button>
              ))}
            </div>
            {activeQuery === 'todo' && (
              <form
                className="mt-3 space-y-2 rounded-2xl border border-white/10 bg-black/30 p-3 text-xs text-white"
                onSubmit={event => {
                  event.preventDefault();
                  if (!newTodoDraft.title.trim()) return;
                  addTask(directoryNode!.id, newTodoDraft.title.trim(), newTodoDraft.description.trim(), [], []);
                  setNewTodoDraft({ title: '', description: '' });
                }}
              >
                <p className="text-[10px] uppercase tracking-[0.3em] text-foreground/50">Add Todo</p>
                <input
                  value={newTodoDraft.title}
                  onChange={event => setNewTodoDraft(current => ({ ...current, title: event.target.value }))}
                  placeholder="Title"
                  className="w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-xs text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                />
                <textarea
                  value={newTodoDraft.description}
                  onChange={event => setNewTodoDraft(current => ({ ...current, description: event.target.value }))}
                  placeholder="Description"
                  rows={2}
                  className="w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-xs text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                />
                <button
                  type="submit"
                  className="w-full rounded-xl bg-emerald-500/70 px-3 py-2 text-[10px] font-semibold uppercase tracking-[0.3em] text-emerald-950 hover:bg-emerald-400"
                >
                  Add Todo
                </button>
              </form>
            )}
              {activeQuery && activeQuery !== 'todo' && (
              <form
                className="mt-3 space-y-2 rounded-2xl border border-white/10 bg-black/30 p-3 text-xs text-white"
                onSubmit={event => {
                  event.preventDefault();
                  if (!newTypedVarDraft.name.trim() || !directoryNode) return;
                  const derivedType =
                    newTypedVarDraft.label.trim() || activeQueryLabel || activeQuery || 'Value';
                  addVariable(directoryNode.id, newTypedVarDraft.name.trim(), derivedType);
                  setNewTypedVarDraft({ name: '', label: '' });
                }}
              >
                <p className="text-[10px] uppercase tracking-[0.3em] text-foreground/50">Add {activeQueryLabel || activeQuery}</p>
                <input
                  value={newTypedVarDraft.name}
                  onChange={event => setNewTypedVarDraft(current => ({ ...current, name: event.target.value }))}
                  placeholder="Name"
                  className="w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-xs text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                />
                <input
                  value={newTypedVarDraft.label}
                  onChange={event => setNewTypedVarDraft(current => ({ ...current, label: event.target.value }))}
                  placeholder="Custom type (optional)"
                  className="w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-xs text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                />
                <button
                  type="submit"
                  className="w-full rounded-xl bg-white/10 px-3 py-2 text-[10px] font-semibold uppercase tracking-[0.3em] text-white hover:bg-white/20"
                >
                  Add {activeQueryLabel || activeQuery}
                </button>
              </form>
            )}
          </div>

          <h4 className="text-xs uppercase tracking-[0.4em] text-foreground/50">Entries</h4>
          <ul className="mt-3 space-y-2 text-sm">
            {currentEntries.map(entry => (
              <li
                key={`${directoryNode?.id ?? 'root'}-${entry.name}`}
                className="flex items-center justify-between rounded-xl border border-white/10 px-3 py-2"
              >
                <div>
                  <p className="text-white">{entry.name}</p>
                  <p className="text-xs text-foreground/50">{entry.ref.kind === 'node' ? 'node' : 'alias'}</p>
                </div>
                <div className="mt-3 space-y-2">
                  <label className="text-xs uppercase tracking-[0.3em] text-foreground/50">Requires facts</label>
                  <div className="flex gap-2">
                    <input
                      value={taskDraft.factInput}
                      onChange={event => setTaskDraft(current => ({ ...current, factInput: event.target.value }))}
                      placeholder="Fact type (e.g., HasSugar)"
                      className="flex-1 rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-xs text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                    />
                    <button
                      type="button"
                      className="rounded-xl bg-white/10 px-3 py-2 text-[10px] font-semibold uppercase tracking-[0.3em] text-white hover:bg-white/20"
                      onClick={() => {
                        if (!taskDraft.factInput.trim()) return;
                        if (taskDraft.requiredFacts.includes(taskDraft.factInput.trim())) return;
                        setTaskDraft(current => ({
                          ...current,
                          requiredFacts: [...current.requiredFacts, current.factInput.trim()],
                          factInput: '',
                        }));
                      }}
                    >
                      Add fact
                    </button>
                  </div>
                  <div className="flex flex-wrap gap-2">
                    {taskDraft.requiredFacts.map(fact => (
                      <button
                        key={fact}
                        type="button"
                        onClick={() =>
                          setTaskDraft(current => ({
                            ...current,
                            requiredFacts: current.requiredFacts.filter(item => item !== fact),
                          }))
                        }
                        className="rounded-full border border-white/10 bg-white/5 px-3 py-1 text-[10px] uppercase tracking-[0.3em] text-white hover:border-white/40"
                      >
                        {fact} ×
                      </button>
                    ))}
                    {taskDraft.requiredFacts.length === 0 && (
                      <span className="text-xs text-foreground/50">No fact requirements yet.</span>
                    )}
                  </div>
                </div>
                <button
                  type="button"
                  className="rounded-full border border-white/20 px-3 py-1 text-xs text-white/70 hover:border-white/50"
                  onClick={() => handleEntryNavigate(entry.name)}
                >
                  Zoom
                </button>
              </li>
            ))}
            {currentEntries.length === 0 && (
              <li className="rounded-xl border border-dashed border-white/20 px-3 py-2 text-xs text-foreground/60">
                Nothing here yet. Add expressions or scopes from the editor.
              </li>
            )}
          </ul>

          <div className="mt-6">
            <h5 className="text-xs uppercase tracking-[0.4em] text-foreground/50">Available variables</h5>
            <div className="mt-3 max-h-48 overflow-y-auto">
              <ScopeVariableList variables={availableVariablesForDrop} onInspect={setFocusedVariableId} />
            </div>
          </div>
        </aside>

        <div className="space-y-6">
          {scopeMetadata && (
            <div className="rounded-2xl border border-white/10 bg-black/10 p-4">
              <div className="mb-3 flex items-center justify-between">
                <div>
                  <p className="text-xs uppercase tracking-[0.4em] text-foreground/50">Scope</p>
                  <h4 className="text-xl font-semibold text-white">{scopeMetadata.label}</h4>
                </div>
                <div className="flex items-center gap-2">
                  <span className="rounded-full border border-white/10 px-3 py-1 text-xs text-foreground/60">
                    {scopeMetadata.completed ? 'Completed' : 'Scope'}
                  </span>
                  {parentScopeId && !scopeMetadata.completed && (
                    <button
                      type="button"
                      onClick={() => completeScope(directoryNode!.id, parentScopeId)}
                      className="rounded-full border border-emerald-400/50 px-3 py-1 text-xs uppercase tracking-widest text-emerald-200 hover:bg-emerald-500/10"
                    >
                      Bubble resources ↑
                    </button>
                  )}
                </div>
              </div>
              {resolved.crumbs.length === 1 && isAgentQuery && (
                <div className="mb-4 rounded-xl border border-dashed border-white/20 p-3">
                  <p className="text-xs uppercase tracking-[0.4em] text-foreground/50">Agents</p>
                  <form
                    className="mt-2 grid gap-2 md:grid-cols-4"
                    onSubmit={event => {
                      event.preventDefault();
                      if (!personDraft.name.trim()) return;
                      addPerson(personDraft.name.trim(), Math.max(0, personDraft.budget), Math.max(0, personDraft.hours));
                      setPersonDraft({ name: '', budget: 100, hours: 10 });
                    }}
                  >
                    <input
                      value={personDraft.name}
                      onChange={event => setPersonDraft(current => ({ ...current, name: event.target.value }))}
                      placeholder="Person name"
                      className="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                    />
                    <input
                      type="number"
                      min={0}
                      value={personDraft.budget}
                      onChange={event => setPersonDraft(current => ({ ...current, budget: Number(event.target.value) }))}
                      placeholder="Budget ($)"
                      className="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                    />
                    <input
                      type="number"
                      min={0}
                      value={personDraft.hours}
                      onChange={event => setPersonDraft(current => ({ ...current, hours: Number(event.target.value) }))}
                      placeholder="Calendar hours"
                      className="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                    />
                    <button
                      type="submit"
                      className="rounded-xl bg-emerald-500/80 px-4 py-2 text-xs font-semibold uppercase tracking-widest text-emerald-950 hover:bg-emerald-400"
                    >
                      Add agent
                    </button>
                  </form>
                  <p className="mt-2 text-xs text-foreground/60">
                    Agents automatically inherit a budget and calendar that can be partitioned into sub-allocations.
                  </p>
                </div>
              )}

              <form
                className="space-y-3"
                onSubmit={event => {
                  event.preventDefault();
                  if (!variableDraft.name.trim()) return;
                  const resource =
                    resourceDraft.kind === 'none'
                      ? undefined
                      : {
                          kind: resourceDraft.kind,
                          label:
                            resourceDraft.label ||
                            (resourceDraft.kind === 'budget'
                              ? 'Budget'
                              : resourceDraft.kind === 'time'
                                ? 'Time'
                                : resourceDraft.unit || 'Resource'),
                          quantity:
                            resourceDraft.kind === 'time'
                              ? sumSlotHours(resourceDraft.timeSlots)
                              : resourceDraft.quantity,
                          unit:
                            resourceDraft.kind === 'budget'
                              ? 'USD'
                              : resourceDraft.kind === 'time'
                                ? 'hours'
                                : resourceDraft.unit || 'unit',
                          consumable: resourceDraft.kind === 'fact' ? false : resourceDraft.consumable,
                          sourceVariableId: resourceDraft.sourceVariableId,
                          resourceType:
                            resourceDraft.resourceType ??
                            (resourceDraft.kind === 'fact' ? 'Fact' : 'Resource'),
                          origin: 'manual' as const,
                          timeSlots: resourceDraft.kind === 'time' ? [...resourceDraft.timeSlots] : undefined,
                          factType:
                            resourceDraft.kind === 'fact'
                              ? resourceDraft.factType || resourceDraft.label || 'Fact'
                              : undefined,
                        };
                  addVariable(
                    directoryNode!.id,
                    variableDraft.name.trim(),
                    variableDraft.type.trim() || 'Value',
                    resource,
                  );
                  setVariableDraft({ name: '', type: '' });
                  setResourceDraft({
                    kind: 'none',
                    quantity: 0,
                    unit: '',
                    label: '',
                    consumable: true,
                    sourceVariableId: undefined,
                    resourceType: 'Resource',
                    timeSlots: [],
                    factType: '',
                  });
                }}
              >
                <div className="grid gap-3 md:grid-cols-2">
                  <input
                    value={variableDraft.name}
                    onChange={event => setVariableDraft(current => ({ ...current, name: event.target.value }))}
                    placeholder="Variable name"
                    className="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                  />
                  <input
                    value={variableDraft.type}
                    onChange={event => setVariableDraft(current => ({ ...current, type: event.target.value }))}
                    placeholder="Type annotation"
                    className="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                  />
                </div>
                <div className="grid gap-3 md:grid-cols-2">
                  <div>
                    <label className="text-xs uppercase tracking-[0.4em] text-foreground/50">Resource kind</label>
                    <select
                      value={resourceDraft.kind}
                      onChange={event =>
                        setResourceDraft(current => ({
                          ...current,
                          kind: event.target.value as ResourceKind,
                        }))
                      }
                      className="mt-1 w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                    >
                      <option value="none">None</option>
                      <option value="budget">Budget (money)</option>
                      <option value="time">Calendar time</option>
                      <option value="asset">Asset / equipment</option>
                      <option value="custom">Custom</option>
                      <option value="fact">Fact / proof</option>
                    </select>
                  </div>
                  {(resourceDraft.kind === 'asset' || resourceDraft.kind === 'custom') && (
                    <input
                      value={resourceDraft.label}
                      onChange={event => setResourceDraft(current => ({ ...current, label: event.target.value }))}
                      placeholder="Resource label (e.g., Drill)"
                      className="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                    />
                  )}
                </div>
                {resourceDraft.kind !== 'none' && (
                  <div className="grid gap-3 md:grid-cols-3">
                    <input
                      type="number"
                      min={0}
                      value={resourceDraft.kind === 'time' ? sumSlotHours(resourceDraft.timeSlots) : resourceDraft.quantity}
                      onChange={event =>
                        resourceDraft.kind === 'time'
                          ? undefined
                          : setResourceDraft(current => ({ ...current, quantity: Number(event.target.value) }))
                      }
                      placeholder="Quantity"
                      className={`rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20 ${
                        resourceDraft.kind === 'time' ? 'cursor-not-allowed opacity-50' : ''
                      }`}
                      readOnly={resourceDraft.kind === 'time'}
                    />
                    {(resourceDraft.kind === 'asset' || resourceDraft.kind === 'custom') && (
                      <input
                        value={resourceDraft.unit}
                        onChange={event => setResourceDraft(current => ({ ...current, unit: event.target.value }))}
                        placeholder="Unit (e.g., units, hrs)"
                        className="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                      />
                    )}
                    {resourceDraft.kind === 'fact' && (
                      <input
                        value={resourceDraft.factType ?? ''}
                        onChange={event => setResourceDraft(current => ({ ...current, factType: event.target.value }))}
                        placeholder="Fact type (e.g., HasSugar)"
                        className="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                      />
                    )}
                    <label className="flex items-center gap-2 text-xs uppercase tracking-[0.3em] text-foreground/50">
                      <input
                        type="checkbox"
                        checked={resourceDraft.consumable}
                        onChange={event => setResourceDraft(current => ({ ...current, consumable: event.target.checked }))}
                        className="accent-emerald-500"
                      />
                      Consumable
                    </label>
                  </div>
                )}
                {resourceDraft.kind !== 'none' && (
                  <input
                    value={resourceDraft.resourceType}
                    onChange={event => setResourceDraft(current => ({ ...current, resourceType: event.target.value }))}
                    placeholder="Type label (Budget, Drill, Calendar...)"
                    className="w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                  />
                )}
                <div className="flex items-center gap-2">
                  <label className="text-xs uppercase tracking-[0.4em] text-foreground/50">Allocate from parent</label>
                  <InfoHint title="Parent resources" body="Select a variable from an ancestor scope to carve out a linear slice. Budget slices subtract dollars; calendar slices subtract specific time slots." />
                <select
                    value={resourceDraft.sourceVariableId ?? ''}
                    onChange={event =>
                      setResourceDraft(current => ({
                        ...current,
                        sourceVariableId: event.target.value || undefined,
                        timeSlots: [],
                      }))
                    }
                    className="mt-1 w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                  >
                    <option value="">None</option>
                    {availableVariablesForDrop
                      .filter(variable => variable.resource && variable.resource.consumable && (variable.resource.kind !== 'time' ? variable.resource.quantity > 0 : (variable.resource.timeSlots ?? []).length > 0))
                      .map(variable => (
                        <option key={variable.id} value={variable.id}>
                          {variable.name} · {formatResourceSummary(variable.resource)}
                        </option>
                      ))}
                  </select>
                </div>
                {resourceDraft.kind === 'time' && (
                  <div className="space-y-2 rounded-2xl border border-dashed border-white/20 p-3 text-xs text-foreground/60">
                    <div className="flex items-center justify-between">
                      <p className="uppercase tracking-[0.3em]">Sub-calendar slots</p>
                      <button
                        type="button"
                        onClick={openCalendarPicker}
                        disabled={!parentResourceVariable || (parentResourceVariable.resource?.kind === 'time' && (parentResourceVariable.resource.timeSlots ?? []).length === 0)}
                        className="rounded-full border border-white/20 px-3 py-1 text-[10px] uppercase tracking-[0.3em] text-white/70 hover:border-white/50 disabled:cursor-not-allowed disabled:opacity-40"
                      >
                        Choose slots
                      </button>
                    </div>
                    {resourceDraft.timeSlots.length === 0 && <p>Select time slices from a parent calendar to make this scope schedulable.</p>}
                    {resourceDraft.timeSlots.length > 0 && (
                      <ul className="space-y-1 text-white">
                        {resourceDraft.timeSlots.map(slot => (
                          <li key={slot.id} className="rounded border border-white/10 px-2 py-1 text-xs">
                            {formatSlotLabel(slot)}
                          </li>
                        ))}
                      </ul>
                    )}
                  </div>
                )}
                <button
                  type="submit"
                  className="w-full rounded-xl bg-white/10 px-4 py-2 text-xs font-semibold uppercase tracking-widest text-white hover:bg-white/20"
                >
                  Save variable
                </button>
              </form>

              <div className="mt-4 grid gap-4 md:grid-cols-2">
                <form
                  className="space-y-2"
                  onSubmit={event => {
                    event.preventDefault();
                    if (!expressionDraft.label.trim() || !expressionDraft.typeName.trim()) return;
                    addExpression(directoryNode!.id, expressionDraft.label.trim(), expressionDraft.typeName.trim());
                    setExpressionDraft({ label: '', typeName: '' });
                  }}
                >
                  <p className="text-xs uppercase tracking-[0.4em] text-foreground/50">New expression</p>
                  <input
                    value={expressionDraft.label}
                    onChange={event => setExpressionDraft(current => ({ ...current, label: event.target.value }))}
                    placeholder="Label"
                    className="w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                  />
                  <input
                    value={expressionDraft.typeName}
                    onChange={event => setExpressionDraft(current => ({ ...current, typeName: event.target.value }))}
                    placeholder="Type"
                    className="w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                  />
                  <button
                    type="submit"
                    className="w-full rounded-xl bg-emerald-500/80 px-4 py-2 text-xs font-semibold uppercase tracking-widest text-emerald-950 hover:bg-emerald-400"
                  >
                    Add expression
                  </button>
                </form>

                <form
                  className="space-y-2"
                  onSubmit={event => {
                    event.preventDefault();
                    if (!childScopeDraft.trim()) return;
                    addChildScope(directoryNode!.id, childScopeDraft.trim());
                    setChildScopeDraft('');
                  }}
                >
                  <p className="text-xs uppercase tracking-[0.4em] text-foreground/50">Nested scope</p>
                  <input
                    value={childScopeDraft}
                    onChange={event => setChildScopeDraft(event.target.value)}
                    placeholder="Scope label"
                    className="w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-white placeholder:text-foreground/40 focus:border-white/40 focus:outline-none focus:ring-2 focus:ring-white/20"
                  />
                  <button
                    type="submit"
                    className="w-full rounded-xl bg-indigo-500/80 px-4 py-2 text-xs font-semibold uppercase tracking-widest text-indigo-950 hover:bg-indigo-400"
                  >
                    Add scope
                  </button>
                </form>
              </div>
            </div>
          )}
        </div>
      )}

          {expressionMetadata && (
            <ExpressionEditorCard
              metadata={expressionMetadata}
              variables={availableVariablesForDrop}
              onAddField={name => addFieldToExpression(directoryNode!.id, name)}
              onSetBinding={(fieldId, binding) => setFieldBinding(directoryNode!.id, fieldId, binding)}
              onSpawnChild={(fieldId, fieldName) => spawnFieldExpression(directoryNode!.id, fieldId, fieldName)}
              onNavigateToChild={fieldName => handleEntryNavigate(fieldName)}
            />
          )}
        </div>
      </div>
      <CalendarModal
        open={calendarModal.open}
        slots={calendarModalSlots}
        selectedSlotIds={calendarSelection}
        onToggleSlot={handleCalendarToggle}
        onClose={() => setCalendarModal({ open: false, selectedIds: [], parent: undefined, onSave: undefined })}
        onSave={handleCalendarSave}
        title={calendarModal.parent?.name ?? 'Calendar'}
      />
    </div>
  );
};

export default FosScopeBuilder;
const findVariableLocation = (
  nodes: Record<ContentId, MerkleNode>,
  variableId: string,
): { scopeId: ContentId; variable: ScopeVariable } | null => {
  for (const [nodeId, node] of Object.entries(nodes)) {
    if (!isDirectory(node) || !isScopeMetadata(node.metadata)) continue;
    const match = node.metadata.variables.find(variable => variable.id === variableId);
    if (match) {
      return { scopeId: nodeId as ContentId, variable: match };
    }
  }
  return null;
};
const adjustVariableResource = (
  nodes: Record<ContentId, MerkleNode>,
  variableId: string,
  delta: number,
  options?: { timeSlots?: CalendarSlot[] }
): Record<ContentId, MerkleNode> | null => {
  const location = findVariableLocation(nodes, variableId);
  if (!location) return null;
  const { scopeId } = location;
  const scopeNode = nodes[scopeId];
  if (!isDirectory(scopeNode) || !isScopeMetadata(scopeNode.metadata)) return null;
  const metadata = cloneScopeMetadata(scopeNode.metadata);
  const variable = metadata.variables.find(entry => entry.id === variableId);
  if (!variable || !variable.resource || !variable.resource.consumable) return null;
  if (variable.resource.kind === 'time') {
    if (options?.timeSlots && options.timeSlots.length > 0) {
      const parentSlots = variable.resource.timeSlots ?? [];
      const slotIds = new Set(options.timeSlots.map(slot => slot.id));
      if (!options.timeSlots.every(slot => parentSlots.some(parentSlot => parentSlot.id === slot.id))) {
        return null;
      }
      variable.resource.timeSlots = parentSlots.filter(slot => !slotIds.has(slot.id));
      variable.resource.quantity = sumSlotHours(variable.resource.timeSlots ?? []);
    } else {
      const nextQuantity = variable.resource.quantity + delta;
      if (nextQuantity < 0) return null;
      variable.resource = { ...variable.resource, quantity: nextQuantity };
    }
  } else {
    const nextQuantity = variable.resource.quantity + delta;
    if (nextQuantity < 0) return null;
    variable.resource = { ...variable.resource, quantity: nextQuantity };
  }
  return {
    ...nodes,
    [scopeId]: { ...scopeNode, metadata },
  };
};
